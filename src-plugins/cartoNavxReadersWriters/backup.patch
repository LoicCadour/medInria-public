diff --git a/src-plugins/CMakeLists.txt b/src-plugins/CMakeLists.txt
index c1ad3b8..195da60 100644
--- a/src-plugins/CMakeLists.txt
+++ b/src-plugins/CMakeLists.txt
@@ -82,6 +82,8 @@ set(PLUGIN_LIST
   itkDataSHImage                 ON
   itkDataSHImageWriter           ON
   itkDataSHImageReader           ON
+  
+  cartoNavxReadersWriters        ON
   )
 
 if (MEDINRIA-PLUGINS_BUILD_EXAMPLES)
diff --git a/src-plugins/cartoNavxReadersWriters/CMakeLists.txt b/src-plugins/cartoNavxReadersWriters/CMakeLists.txt
new file mode 100644
index 0000000..8d50680
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/CMakeLists.txt
@@ -0,0 +1,91 @@
+## #################################################################
+## Generated by medPluginGenerator
+## #################################################################
+
+cmake_minimum_required(VERSION 2.8.1)
+
+project(cartoNavxReadersWritersPlugin)
+
+## #################################################################
+## Setup version numbering
+## #################################################################
+
+set(${PROJECT_NAME}_VERSION ${medInria_VERSION})
+
+string(TOUPPER ${PROJECT_NAME} PROJECT_NAME_UP)
+add_definitions(-D${PROJECT_NAME_UP}_VERSION="${${PROJECT_NAME}_VERSION}")
+
+set(CMAKE_COLOR_MAKEFILE ON)
+set(CMAKE_VERBOSE_MAKEFILE OFF)
+set(CMAKE_INCLUDE_CURRENT_DIR TRUE)
+
+## #################################################################
+## Resolve dependencies
+## #################################################################
+
+find_package(dtk REQUIRED)
+include(${dtk_USE_FILE})
+include(dtkPlugin)
+
+find_package(ITK REQUIRED)
+include(${ITK_USE_FILE})
+
+find_package(VTK)
+include(${VTK_USE_FILE})
+
+## #################################################################
+## Input
+## #################################################################
+
+set(${PROJECT_NAME}_HEADERS_MOC
+  cartoNavxReadersWritersPlugin.h
+  cartoMeshReader.h
+  cartoVtkWriter.h
+  navxDifWriter.h
+  navxDifReader.h)
+
+set(${PROJECT_NAME}_HEADERS
+  ${${PROJECT_NAME}_HEADERS_MOC})
+
+set(${PROJECT_NAME}_SOURCES
+  cartoNavxReadersWritersPlugin.cpp
+  cartoMeshReader.cpp
+  cartoVtkWriter.cpp
+  navxDifWriter.cpp
+  navxDifReader.cpp)
+
+## #################################################################
+## Build rules
+## #################################################################
+
+qt4_wrap_cpp(${PROJECT_NAME}_SOURCES_MOC ${${PROJECT_NAME}_HEADERS_MOC})
+
+add_library(${PROJECT_NAME} SHARED
+  ${${PROJECT_NAME}_SOURCES_MOC} 
+  ${${PROJECT_NAME}_SOURCES}
+  ${${PROJECT_NAME}_HEADERS})
+
+target_link_libraries(${PROJECT_NAME}
+  ${QT_LIBRARIES}
+  dtkCore
+  medCore
+  vtkCommon
+  vtkDataManagement
+  vtkVisuManagement
+)
+
+## #################################################################
+## Source file layout in development environments like Visual Studio
+## #################################################################
+
+SOURCE_GROUP("Header Files" REGULAR_EXPRESSION .*\\.h\$)
+SOURCE_GROUP("Generated Files" FILES ${${PROJECT_NAME}_SOURCES_MOC})
+
+## #################################################################
+## Install rules
+## #################################################################
+
+install(TARGETS ${PROJECT_NAME}
+  RUNTIME DESTINATION plugins
+  LIBRARY DESTINATION plugins
+  ARCHIVE DESTINATION lib)
diff --git a/src-plugins/cartoNavxReadersWriters/cartoMeshReader.cpp b/src-plugins/cartoNavxReadersWriters/cartoMeshReader.cpp
new file mode 100644
index 0000000..2b490d5
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/cartoMeshReader.cpp
@@ -0,0 +1,461 @@
+#include <cartoMeshReader.h>
+
+#include <dtkCore/dtkAbstractDataFactory.h>
+#include <dtkCore/dtkSmartPointer.h>
+
+#include <medAbstractData.h>
+
+#include <vtkMetaSurfaceMesh.h>
+#include <vtkPolyData.h>
+#include <vtkIdList.h>
+#include <vtkDoubleArray.h>
+#include <vtkPointData.h>
+
+// /////////////////////////////////////////////////////////////////
+// cartoMeshReaderPrivate
+// /////////////////////////////////////////////////////////////////
+
+struct GeneralAttributes
+{
+    GeneralAttributes()
+    {
+        numVertex = numTriangles = 0;
+        numVertexColors = 0;
+        topologyStatus = -1;
+        meshColor.setRgba(qRgba(0,1,0,1)); // default color per the spec is green
+    }
+
+    QString meshName;
+    unsigned int numVertex;
+    unsigned int numTriangles;
+
+    unsigned int numVertexColors;
+    QStringList colorsNames;
+    QColor meshColor;
+    int topologyStatus;
+    QMatrix4x4 matrix;
+};
+
+class cartoMeshReaderPrivate
+{
+  public:
+    cartoMeshReaderPrivate()
+        : versionRE("#TriangulatedMeshVersion(\\d)\\.(\\d)")
+        , sectionTitleRE("\\[([a-z]+)\\]", Qt::CaseInsensitive)
+        , keyValueRE("([0-9a-z]+)\\s*=\\s*((?:\\S+\\s*)*)", Qt::CaseInsensitive)
+        , valuesRE("(\\S+)")
+        , skippableLineRE(";.*")
+        , metaDataSet(NULL)
+        , polyData(NULL)
+        , points(NULL)
+        , idList(NULL)
+        , scalarsArrays(NULL)
+    {
+    }
+
+    QRegExp versionRE;
+    QRegExp sectionTitleRE;
+    QRegExp keyValueRE;
+    QRegExp valuesRE;
+    QRegExp skippableLineRE;
+
+    GeneralAttributes generalAttributes;
+    vtkMetaDataSet * metaDataSet;
+    vtkPolyData * polyData;
+    vtkPoints * points;
+    vtkIdList * idList;
+    vtkDoubleArray ** scalarsArrays;
+};
+
+typedef bool (cartoMeshReader::*ProcessorMemberFunc)(const QString &, const QStringList &);
+
+
+typedef enum {
+    Not_Started,
+    Read_Version,
+    Read_Section,
+    Read_KeyValues,
+    Read_MoreValues
+} IniState;
+
+#define PARSE_ERROR(format, ...) do{qDebug("cartoMeshReader [at line %d]: " format, lineCount, ##__VA_ARGS__);return false;}while(0);
+#define PARSE_FAILED PARSE_ERROR("Parsing '%s' failed", qPrintable(path))
+
+// /////////////////////////////////////////////////////////////////
+// cartoMeshReader
+// /////////////////////////////////////////////////////////////////
+
+cartoMeshReader::cartoMeshReader(void) : dtkAbstractDataReader(), d(new cartoMeshReaderPrivate)
+{
+
+}
+
+
+cartoMeshReader::~cartoMeshReader(void)
+{
+    if (d)
+    {
+        if (d->metaDataSet)
+            d->metaDataSet->Delete();
+        d->metaDataSet = NULL;
+        if (d->polyData)
+            d->polyData->Delete();
+        d->polyData = NULL;
+        if (d->points)
+            d->points->Delete();
+        d->points = NULL;
+        if (d->idList)
+            d->idList->Delete();
+        d->idList = NULL;
+        if (d->scalarsArrays)
+        {
+            for(unsigned int i = 0; i < d->generalAttributes.numVertexColors; ++i)
+            {
+                if (d->scalarsArrays[i]) d->scalarsArrays[i]->Delete();
+                d->scalarsArrays[i] = NULL;
+            }
+            delete[] d->scalarsArrays;
+            d->scalarsArrays = NULL;
+        }
+    }
+    delete d;
+    d = NULL;
+}
+
+
+QString cartoMeshReader::identifier() const
+{
+    return QString("cartoMeshReader");
+}
+
+
+QString cartoMeshReader::description(void) const
+{
+    return QString("Reader for BioSense CARTO .mesh files");
+}
+
+
+QStringList cartoMeshReader::handled(void) const
+{
+    return QStringList() << "vtkDataMesh";
+}
+
+
+bool cartoMeshReader::registered(void)
+{
+    return dtkAbstractDataFactory::instance()->registerDataReaderType("cartoMeshReader", QStringList() << "vtkDataMesh", create);
+}
+
+
+bool cartoMeshReader::canRead(const QString & path)
+{
+    if (path.endsWith(".mesh"))
+        return true;
+    return false;
+}
+
+
+bool cartoMeshReader::read(const QString & path)
+{
+    qDebug() << "Can read with: " << identifier();
+
+    QFile file(path);
+    if( ! file.open(QIODevice::ReadOnly))
+    {
+        qWarning("cartoMeshReader: File could not be opened for reading");
+        return false;
+    }
+
+    dtkSmartPointer<dtkAbstractData> meshData = dtkAbstractDataFactory::instance()->createSmartPointer("vtkDataMesh");
+    d->metaDataSet = vtkMetaSurfaceMesh::New();
+    d->polyData = vtkPolyData::New();
+    d->points = vtkPoints::New();
+
+    QByteArray line;
+    int lineCount = -1;
+
+    IniState currentState = Not_Started;
+    int version = -1;
+    QString currentSection;
+    QString currentKey;
+    QStringList currentValues;
+    ProcessorMemberFunc currentProcessor = NULL;
+    while( ! file.atEnd() )
+    {
+        currentValues.clear();
+
+        line = file.readLine().trimmed();
+        lineCount++;
+
+        if (canSkipLine(line)) continue;
+
+        if (currentState == Not_Started && canReadVersion(line, version))
+        {
+            if (version != 2 /*&& version != 3*/)
+                PARSE_ERROR("unsupported version : %d", version);
+            currentState = Read_Version;
+        }
+        else if( (currentState == Read_Version || currentState == Read_Section || currentState == Read_KeyValues ) && canReadSection(line, currentSection))
+        {
+            if(currentSection == "GeneralAttributes")
+                currentProcessor = &cartoMeshReader::processGeneralAttributes;
+            else if(currentSection == "VerticesSection")
+            {
+                if(d->generalAttributes.topologyStatus != 0)
+                {
+                    qDebug("cartoMeshReader: the TopologyStatus is not supported");
+                    return false;
+                }
+                if (d->generalAttributes.numVertex == 0)
+                {
+                    qDebug("cartoMeshReader: no vertices in the mesh !");
+                    return false;
+                }
+                d->points->SetNumberOfPoints(d->generalAttributes.numVertex);
+                currentProcessor = &cartoMeshReader::processVertice;
+            }
+            else if(currentSection == "TrianglesSection")
+            {
+                if (d->generalAttributes.numTriangles == 0)
+                {
+                    qDebug("cartoMeshReader: NumTriangle == 0 !");
+                    return false;
+                }
+                if (d->points->GetNumberOfPoints() == 0)
+                {
+                    qDebug("cartoMeshReader: no vertices in the mesh !");
+                    return false;
+                }
+                d->polyData->SetPoints(d->points);
+                d->polyData->Allocate(d->generalAttributes.numTriangles);
+                d->idList = vtkIdList::New();
+                d->idList->SetNumberOfIds(3);
+                currentProcessor = &cartoMeshReader::processTriangles;
+            }
+            else if(currentSection == "VerticesColorsSection")
+            {
+                if (d->generalAttributes.numVertexColors == 0)
+                {
+                    qDebug("cartoMeshReader: VerticesColorsSection section with NumVertexColors == 0");
+                    currentProcessor = NULL;
+                }
+                else
+                {
+                    d->scalarsArrays = new vtkDoubleArray*[d->generalAttributes.numVertexColors];
+                    for(unsigned int i = 0; i < d->generalAttributes.numVertexColors; ++i)
+                    {
+                        d->scalarsArrays[i] = vtkDoubleArray::New();
+                        d->scalarsArrays[i]->SetNumberOfComponents(1);
+                        d->scalarsArrays[i]->SetNumberOfValues(d->generalAttributes.numVertex);
+                        if ((unsigned int)d->generalAttributes.colorsNames.size() > i)
+                            d->scalarsArrays[i]->SetName(d->generalAttributes.colorsNames.at(i).toUtf8().constData());
+                        else
+                            d->scalarsArrays[i]->SetName(QString("__attribute_%d").arg(i).toAscii().constData());
+                    }
+                    currentProcessor = &cartoMeshReader::processVerticesColors;
+                }
+            }
+
+            currentState = Read_Section;
+        }
+        else if ((currentState == Read_Section || currentState == Read_KeyValues ) && canReadKeyValues(line, currentKey, currentValues))
+        {
+            if(currentProcessor)
+                (this->*currentProcessor)(currentKey, currentValues);
+            currentState = Read_KeyValues;
+        }
+        else PARSE_FAILED;
+
+        this->setProgress(file.pos() / file.size() * 100);
+    }
+
+    d->polyData->Update();
+
+    if (d->polyData->GetNumberOfPoints() == 0 || d->polyData->GetNumberOfCells() == 0)
+        return false;
+
+    d->metaDataSet->SetDataSet(d->polyData);
+    for(unsigned int i = 0; i < d->generalAttributes.numVertexColors; ++i)
+    {
+        d->metaDataSet->GetDataSet()->GetPointData()->AddArray(d->scalarsArrays[i]);
+        // Apparently this is the null value for scalar data, but it's not documented anywhere...
+        d->metaDataSet->SetScalarNullValue(d->scalarsArrays[i]->GetName(), -10000.0);
+    }
+
+    meshData->setData(d->metaDataSet);
+    this->setData(meshData);
+
+    return true;
+}
+
+
+bool cartoMeshReader::canReadVersion(const QByteArray & line, int & version)
+{
+    if(d->versionRE.exactMatch(line))
+    {
+        bool ok;
+        version = d->versionRE.cap(1).toInt(&ok);
+        return ok;
+    }
+    return false;
+}
+
+
+bool cartoMeshReader::canReadSection(const QByteArray & line, QString & title)
+{
+    if(d->sectionTitleRE.exactMatch(line))
+    {
+        title = d->sectionTitleRE.cap(1);
+        qDebug() << "Title:" << title;
+        return true;
+    }
+    return false;
+}
+
+
+bool cartoMeshReader::canReadKeyValues(const QByteArray & line, QString & key, QStringList & values)
+{
+    if(d->keyValueRE.exactMatch(line))
+    {
+        key = d->keyValueRE.cap(1);
+        int pos = 0;
+        while( (pos = d->valuesRE.indexIn(d->keyValueRE.cap(2), pos)) != -1 )
+        {
+            values.append(d->valuesRE.cap(1));
+            pos += d->valuesRE.matchedLength();
+        }
+        return true;
+    }
+    return false;
+}
+
+
+bool cartoMeshReader::canSkipLine(const QByteArray & line)
+{
+    if (line.isEmpty() || d->skippableLineRE.exactMatch(line))
+        return true;
+    return false;
+}
+
+
+bool cartoMeshReader::processGeneralAttributes(const QString & key, const QStringList & values)
+{
+    if (values.isEmpty())
+        return false;
+
+    if(key == "MeshName")
+        d->generalAttributes.meshName = values.first();
+
+    else if (key == "NumVertex")
+        d->generalAttributes.numVertex = values.first().toInt();
+
+    else if (key == "NumTriangle")
+        d->generalAttributes.numTriangles = values.first().toInt();
+
+    else if (key == "NumVertexColors")
+        d->generalAttributes.numVertexColors = values.first().toInt();
+
+    else if (key == "ColorsNames")
+        d->generalAttributes.colorsNames = values;
+
+    else if (key == "TopologyStatus")
+        d->generalAttributes.topologyStatus = values.first().toInt();
+
+    else if (key == "MeshColor")
+    {
+        if (values.size() != 4)
+        {
+            qDebug("cartoMeshReader: invalid color for meshColor");
+            return false;
+        }
+        d->generalAttributes.meshColor = QColor(values.at(0).toInt(), values.at(1).toInt(),
+                                                values.at(2).toInt(), values.at(3).toInt());
+    }
+    else if (key == "Matrix")
+    {
+        if(values.size() != 16)
+        {
+            qDebug("cartoMeshReader: invalid matrix");
+            return false;
+        }
+        int x = 0, y = 0;
+        foreach(const QString & s, values)
+        {
+            d->generalAttributes.matrix(y, x) = s.toInt();
+            x++;
+            if (x % 4 == 0) {x = 0; y++;}
+        }
+    }
+    return true;
+}
+
+
+bool cartoMeshReader::processVertice(const QString & key, const QStringList & values)
+{
+    if (values.size() < 3)
+        return false;
+
+    bool ok = true;
+    double p[3];
+    for(int i = 0; i < 3 && ok; i++)
+        p[i] = values.at(i).toDouble(&ok);
+    if (!ok)
+        return false;
+
+    unsigned int id = key.toUInt(&ok);
+    if (!ok || id >= d->generalAttributes.numTriangles)
+        return false;
+
+    d->points->InsertPoint(id, p);
+    return true;
+}
+
+
+bool cartoMeshReader::processTriangles(const QString & key, const QStringList & values)
+{
+    if (values.size() < 3)
+        return false;
+
+    bool ok = true;
+    for(unsigned int i = 0; i < 3; i++)
+    {
+        unsigned int id = values.at(i).toUInt(&ok);
+        if (!ok || id >= d->generalAttributes.numVertex)
+            return false;
+        d->idList->InsertId(i, id);
+    }
+
+    d->polyData->InsertNextCell(VTK_TRIANGLE, d->idList);
+    return true;
+}
+
+
+bool cartoMeshReader::processVerticesColors(const QString & key, const QStringList & values)
+{
+    if ((unsigned int)values.size() < d->generalAttributes.numVertexColors)
+        return false;
+
+    bool ok = true;
+    unsigned int id = key.toUInt(&ok);
+    if (!ok || id >= d->generalAttributes.numVertex)
+        return false;
+
+    for(unsigned int i = 0; i < d->generalAttributes.numVertexColors; i++)
+    {
+        double val = values.at(i).toDouble(&ok);
+        if (!ok)
+            return false;
+
+        d->scalarsArrays[i]->InsertValue(id, val);
+    }
+    return true;
+}
+
+// /////////////////////////////////////////////////////////////////
+// Type instantiation
+// /////////////////////////////////////////////////////////////////
+
+dtkAbstractDataReader * cartoMeshReader::create(void)
+{
+    return new cartoMeshReader;
+}
diff --git a/src-plugins/cartoNavxReadersWriters/cartoMeshReader.h b/src-plugins/cartoNavxReadersWriters/cartoMeshReader.h
new file mode 100644
index 0000000..f8d0f7a
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/cartoMeshReader.h
@@ -0,0 +1,41 @@
+#pragma once
+
+#include <dtkCore/dtkAbstractDataReader.h>
+
+#include <cartoNavxReadersWritersPluginExport.h>
+
+class cartoMeshReaderPrivate;
+
+class CARTONAVXREADERSWRITERSPLUGIN_EXPORT cartoMeshReader : public dtkAbstractDataReader
+{
+    Q_OBJECT
+
+public:
+             cartoMeshReader(void);
+    virtual ~cartoMeshReader(void);
+
+    virtual QString identifier() const;
+    virtual QString description(void) const;    
+    virtual QStringList handled(void) const;
+
+    static bool registered(void);
+    static dtkAbstractDataReader * create(void);
+
+public slots:
+    virtual bool canRead(const QString& file);
+    virtual bool read(const QString& file);
+
+private:
+    bool canReadVersion(const QByteArray & line, int & version);
+    bool canReadSection(const QByteArray & line, QString & title);
+    bool canReadKeyValues(const QByteArray & line, QString & key, QStringList & values);
+    bool canReadMoreValues(const QByteArray & line, QStringList & values);
+    bool canSkipLine(const QByteArray & line);
+
+    bool processGeneralAttributes(const QString & key, const QStringList & values);
+    bool processVertice(const QString & key, const QStringList & values);
+    bool processTriangles(const QString & key, const QStringList & values);
+    bool processVerticesColors(const QString & key, const QStringList & values);
+
+    cartoMeshReaderPrivate * d;
+};
diff --git a/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPlugin.cpp b/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPlugin.cpp
new file mode 100644
index 0000000..9c24fb2
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPlugin.cpp
@@ -0,0 +1,61 @@
+#include <cartoNavxReadersWritersPlugin.h>
+
+#include <cartoMeshReader.h>
+#include <cartoVtkWriter.h>
+#include <navxDifWriter.h>
+
+#include <dtkLog/dtkLog.h>
+
+cartoNavxReadersWritersPlugin::cartoNavxReadersWritersPlugin(QObject *parent) : dtkPlugin(parent)
+{
+}
+
+cartoNavxReadersWritersPlugin::~cartoNavxReadersWritersPlugin(void)
+{
+}
+
+bool cartoNavxReadersWritersPlugin::initialize(void)
+{
+    if( ! cartoMeshReader::registered()) {
+        dtkWarn() << "Unable to register cartoMeshReader type";
+    }
+    if( ! cartoVtkWriter::registered()) {
+        dtkWarn() << "Unable to register cartoVtkWriter type";
+    }
+    if( ! navxDifWriter::registered()) {
+        dtkWarn() << "Unable to register navxDifWriter type";
+    }
+    return true;
+}
+
+bool cartoNavxReadersWritersPlugin::uninitialize(void)
+{
+    return true;
+}
+
+QString cartoNavxReadersWritersPlugin::name(void) const
+{
+    return "cartoNavxReadersWritersPlugin";
+}
+
+QString cartoNavxReadersWritersPlugin::description(void) const
+{
+    return "";
+}
+
+QStringList cartoNavxReadersWritersPlugin::authors(void) const
+{
+    return QStringList() << "Florian Vichot";
+}
+
+QStringList cartoNavxReadersWritersPlugin::tags(void) const
+{
+    return QStringList() << "CARTO" << "Mesh";
+}
+
+QStringList cartoNavxReadersWritersPlugin::types(void) const
+{
+    return QStringList() << "cartoMeshReader" << "cartoVtkWriter";
+}
+
+Q_EXPORT_PLUGIN2(cartoNavxReadersWritersPlugin, cartoNavxReadersWritersPlugin)
diff --git a/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPlugin.h b/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPlugin.h
new file mode 100644
index 0000000..4b56511
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPlugin.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include <dtkCore/dtkPlugin.h>
+#include <cartoNavxReadersWritersPluginExport.h>
+
+class CARTONAVXREADERSWRITERSPLUGIN_EXPORT cartoNavxReadersWritersPlugin : public dtkPlugin
+{
+    Q_OBJECT
+    Q_INTERFACES(dtkPlugin)
+
+public:
+     cartoNavxReadersWritersPlugin(QObject *parent = 0);
+    ~cartoNavxReadersWritersPlugin(void);
+
+    virtual bool initialize(void);
+    virtual bool uninitialize(void);
+
+    virtual QString name(void) const;
+    virtual QString description(void) const;
+
+    virtual QStringList authors(void) const;
+    virtual QStringList tags(void) const;
+    virtual QStringList types(void) const;
+};
diff --git a/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPluginExport.h b/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPluginExport.h
new file mode 100644
index 0000000..3fa2c10
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/cartoNavxReadersWritersPluginExport.h
@@ -0,0 +1,11 @@
+#pragma once
+
+#ifdef WIN32
+    #ifdef cartoNavxReadersWritersPlugin_EXPORTS
+        #define CARTONAVXREADERSWRITERSPLUGIN_EXPORT __declspec(dllexport)
+    #else
+        #define CARTONAVXREADERSWRITERSPLUGIN_EXPORT __declspec(dllimport)
+    #endif
+#else
+    #define CARTONAVXREADERSWRITERSPLUGIN_EXPORT
+#endif
diff --git a/src-plugins/cartoNavxReadersWriters/cartoVtkWriter.cpp b/src-plugins/cartoNavxReadersWriters/cartoVtkWriter.cpp
new file mode 100644
index 0000000..bd96974
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/cartoVtkWriter.cpp
@@ -0,0 +1,192 @@
+#include <cartoVtkWriter.h>
+
+#include <dtkCore/dtkAbstractDataFactory.h>
+#include <dtkCore/dtkSmartPointer.h>
+
+#include <medAbstractData.h>
+
+#include <vtkMetaSurfaceMesh.h>
+#include <vtkPolyData.h>
+#include <vtkPolyDataWriter.h>
+#include <vtkSmartPointer.h>
+#include <vtkPointData.h>
+#include <vtkCellData.h>
+#include <vtkDoubleArray.h>
+#include <vtkProperty.h>
+#include <vtkErrorCode.h>
+
+#include <vtkLookupTableManager.h>
+
+// /////////////////////////////////////////////////////////////////
+// cartoVtkWriter
+// /////////////////////////////////////////////////////////////////
+
+cartoVtkWriter::cartoVtkWriter() : dtkAbstractDataWriter()
+{
+}
+
+
+cartoVtkWriter::~cartoVtkWriter()
+{
+}
+
+
+QString cartoVtkWriter::identifier() const
+{
+    return QString("cartoVtkWriter");
+}
+
+
+QString cartoVtkWriter::description() const
+{
+    return QString("BioSense CARTO .vtk mesh exporter");
+}
+
+
+QStringList cartoVtkWriter::handled() const
+{
+    return QStringList() << "vtkDataMesh";
+}
+
+
+QStringList cartoVtkWriter::supportedFileExtensions() const
+{
+    return QStringList() << ".vtk";
+}
+
+
+bool cartoVtkWriter::registered()
+{
+    return dtkAbstractDataFactory::instance()->registerDataWriterType("cartoVtkWriter", QStringList() << "vtkDataMesh", create);
+}
+
+
+bool cartoVtkWriter::canWrite(const QString & path)
+{
+    return path.endsWith(".vtk");
+}
+
+
+bool cartoVtkWriter::write(const QString & path)
+{
+    dtkAbstractData * dtkData = this->data();
+
+    if ( ! dtkData || dtkData->identifier() != "vtkDataMesh") {
+        qDebug() << "cartoVtkWriter: No data provided, or wrong type";
+        return false;
+    }
+
+    vtkMetaSurfaceMesh * dataSet = dynamic_cast<vtkMetaSurfaceMesh*>( (vtkObject*)(dtkData->data()));
+    if ( ! dataSet) {
+        qDebug() << "cartoVtkWriter: not a vtkMetaSurfaceMesh";
+        return false;
+    }
+
+    vtkPolyData * polyData = dataSet->GetPolyData();
+
+    // done this to not touch the actual data loaded
+    vtkSmartPointer<vtkPolyData> tempMesh = vtkPolyData::New();
+    tempMesh->DeepCopy(polyData);
+
+    // done this to create a LUT and save the changes made in the application, in the written vtk file
+    if(!(dataSet->GetCurrentScalarArray()))
+    {
+        for(int i=0;i<tempMesh->GetPointData()->GetNumberOfArrays();i++)
+            tempMesh->GetPointData()->RemoveArray(tempMesh->GetPointData()->GetArrayName(i));
+
+        for(int i=0;i<tempMesh->GetCellData()->GetNumberOfArrays();i++)
+            tempMesh->GetCellData()->RemoveArray(tempMesh->GetCellData()->GetArrayName(i));
+
+        vtkDoubleArray* scalarArray=vtkDoubleArray::New();
+        for(int i=0;i<tempMesh->GetNumberOfPoints();i++)
+            scalarArray->InsertValue(i, 1.0);
+        tempMesh->GetPointData()->SetScalars(scalarArray);
+
+        double rgb[3],alpha;
+        vtkProperty::SafeDownCast(dataSet->GetProperty())->GetColor(rgb);
+        alpha=vtkProperty::SafeDownCast(dataSet->GetProperty())->GetOpacity();
+
+        vtkLookupTable* lut =vtkLookupTableManager::CreateLookupTable(rgb[0],rgb[1],rgb[2],alpha);
+        tempMesh->GetPointData()->GetScalars()->SetLookupTable(lut);
+
+    }
+    else
+    {
+        tempMesh->GetPointData()->GetScalars()->SetLookupTable(polyData->GetPointData()->GetScalars()->GetLookupTable());
+
+        for(int i=0;i<tempMesh->GetPointData()->GetNumberOfArrays();i++)
+            if(((std::string)(tempMesh->GetPointData()->GetArrayName(i))) != ((std::string)(dataSet->GetCurrentScalarArray()->GetName())))
+                tempMesh->GetPointData()->RemoveArray(tempMesh->GetPointData()->GetArrayName(i));
+
+        for(int i=0;i<tempMesh->GetCellData()->GetNumberOfArrays();i++)
+            if(((std::string)(tempMesh->GetPointData()->GetArrayName(i))) != ((std::string)(dataSet->GetCurrentScalarArray()->GetName())))
+                tempMesh->GetPointData()->RemoveArray(tempMesh->GetPointData()->GetArrayName(i));
+
+        // done this to rescale the scalar values to LUT range, required by CARTO Machine
+        rescaleScalarsToLUTRange(tempMesh);
+
+    }
+
+    vtkSmartPointer<vtkPolyDataWriter> writer = vtkPolyDataWriter::New();
+    writer->SetFileName(path.toUtf8().constData());
+
+    try
+    {
+        writer->SetInput (tempMesh);
+        std::string header = "PatientData ";
+        header = header + "Bobby"; //TODO fix this
+
+        writer->SetHeader(header.c_str());
+        writer->Write();
+    }
+    catch (vtkErrorCode::ErrorIds error)
+    {
+        qDebug() << "cartoVtkWriter: " << vtkErrorCode::GetStringFromErrorCode(error);
+        return false;
+    }
+
+    return true;
+}
+
+
+void cartoVtkWriter::rescaleScalarsToLUTRange(vtkPolyData *mesh)
+{
+    if(!(mesh->GetPointData()->GetScalars()))
+        return;
+
+    if(!(mesh->GetPointData()->GetScalars())->GetLookupTable())
+        return;
+
+    double lutRange[2];
+    mesh->GetPointData()->GetScalars()->GetLookupTable()->GetTableRange(lutRange);
+
+    vtkDoubleArray *scalarArray = vtkDoubleArray::New();
+    scalarArray->DeepCopy(mesh->GetPointData()->GetScalars());
+    scalarArray->SetLookupTable(mesh->GetPointData()->GetScalars()->GetLookupTable());
+
+    // check if scalar array has values
+    if(scalarArray)
+    {
+        for(int i=0;i<scalarArray->GetSize();i++)
+        {
+            if(scalarArray->GetValue(i)<lutRange[0])
+                scalarArray->SetValue(i,lutRange[0]);
+            if(scalarArray->GetValue(i)>lutRange[1])
+                scalarArray->SetValue(i,lutRange[1]);
+
+            scalarArray->SetValue(i, ((scalarArray->GetValue(i)) - lutRange[0])/(lutRange[1]-lutRange[0]));
+        }
+
+        // to do check what happens to mesh->GetPointData()->GetScalars()
+        mesh->GetPointData()->SetScalars(scalarArray);
+    }
+}
+
+// /////////////////////////////////////////////////////////////////
+// Type instantiation
+// /////////////////////////////////////////////////////////////////
+
+dtkAbstractDataWriter * cartoVtkWriter::create()
+{
+    return new cartoVtkWriter;
+}
diff --git a/src-plugins/cartoNavxReadersWriters/cartoVtkWriter.h b/src-plugins/cartoNavxReadersWriters/cartoVtkWriter.h
new file mode 100644
index 0000000..e754cfc
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/cartoVtkWriter.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include <dtkCore/dtkAbstractDataWriter.h>
+#include <cartoNavxReadersWritersPluginExport.h>
+
+class vtkPolyData;
+
+class CARTONAVXREADERSWRITERSPLUGIN_EXPORT cartoVtkWriter : public dtkAbstractDataWriter
+{
+    Q_OBJECT
+
+public:
+    cartoVtkWriter();
+    virtual ~cartoVtkWriter();
+
+    virtual QString identifier() const;
+    virtual QString description() const;
+    virtual QStringList handled() const;
+
+    virtual QStringList supportedFileExtensions() const;
+
+    static bool registered();
+    static dtkAbstractDataWriter * create();
+
+public slots:
+    virtual bool canWrite(const QString &file);
+    virtual bool write(const QString &file);
+
+private:
+    void rescaleScalarsToLUTRange(vtkPolyData * mesh);
+};
diff --git a/src-plugins/cartoNavxReadersWriters/navxDifReader.cpp b/src-plugins/cartoNavxReadersWriters/navxDifReader.cpp
new file mode 100644
index 0000000..79f860b
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/navxDifReader.cpp
@@ -0,0 +1,224 @@
+#include <navxDifReader.h>
+
+#include <dtkCore/dtkAbstractDataFactory.h>
+#include <dtkCore/dtkSmartPointer.h>
+
+#include <medAbstractData.h>
+
+#include <vtkMetaSurfaceMesh.h>
+#include <vtkPolyData.h>
+#include <vtkSmartPointer.h>
+#include <vtkErrorCode.h>
+#include <vtkCellArray.h>
+#include <vtkActor.h>
+#include <vtkProperty.h>
+
+#include <QXmlStreamReader>
+
+// /////////////////////////////////////////////////////////////////
+// navxDifReader
+// /////////////////////////////////////////////////////////////////
+
+navxDifReader::navxDifReader() : dtkAbstractDataReader()
+{
+}
+
+
+navxDifReader::~navxDifReader()
+{
+}
+
+
+QString navxDifReader::identifier() const
+{
+    return QString("navxDifReader");
+}
+
+
+QString navxDifReader::description() const
+{
+    return QString("Saint-Jude NavX .dif mesh importer");
+}
+
+
+QStringList navxDifReader::handled() const
+{
+    return QStringList() << "vtkDataMesh";
+}
+
+
+QStringList navxDifReader::supportedFileExtensions() const
+{
+    return QStringList() << ".dif";
+}
+
+
+bool navxDifReader::registered()
+{
+    return dtkAbstractDataFactory::instance()->registerDataReaderType("navxDifReader", QStringList() << "vtkDataMesh", create);
+}
+
+
+bool navxDifReader::canRead(const QString & path)
+{
+    return path.endsWith(".dif");
+}
+
+
+bool navxDifReader::read(const QString & path)
+{
+//    dtkAbstractData * dtkData = this->data();
+
+//    if ( ! dtkData || dtkData->identifier() != "vtkDataMesh") {
+//        qDebug() << "navxDifReader: No data provided, or wrong type";
+//        return false;
+//    }
+
+//    vtkMetaSurfaceMesh * dataSet = dynamic_cast<vtkMetaSurfaceMesh*>( (vtkObject*)(dtkData->data()));
+//    if ( ! dataSet) {
+//        qDebug() << "navxDifReader: not a vtkMetaSurfaceMesh";
+//        return false;
+//    }
+
+//    vtkPolyData * polyData = dataSet->GetPolyData();
+
+//    QList<vtkMetaDataSet*> datasetList;
+//    datasetList.push_back(dataSet); //TODO = this->Input->GetMetaDataSetList();
+
+
+//    QFile difFile(path);
+//    if ( ! difFile.open(QIODevice::WriteOnly) ) {
+//        qDebug() << "navxDifReader: Could not open file" << path;
+//        return false;
+//    }
+
+//    QXmlStreamWriter xmlWriter(&difFile);
+
+//    xmlWriter.setAutoFormatting(true);
+
+//    xmlWriter.writeStartDocument();
+//    xmlWriter.writeStartElement("DIF");
+
+//    xmlWriter.writeStartElement("DIFHeader");
+//    xmlWriter.writeTextElement("Version", "SJM_DIF_3.0");
+//    xmlWriter.writeTextElement("VendorVersion", "NA");
+//    xmlWriter.writeTextElement("PatientName", "NA");
+//    xmlWriter.writeTextElement("PatientID", "NA");
+//    xmlWriter.writeEmptyElement("PatientBirthDate");
+//    xmlWriter.writeTextElement("PatientGender", "NA");
+//    xmlWriter.writeEmptyElement("StudyID");
+//    xmlWriter.writeEmptyElement("SeriesNumber");
+//    xmlWriter.writeEmptyElement("StudyDate");
+//    xmlWriter.writeEmptyElement("StudyTime");
+//    xmlWriter.writeEmptyElement("SeriesTime");
+//    xmlWriter.writeEmptyElement("Modality");
+//    xmlWriter.writeEmptyElement("RefPhysName");
+//    xmlWriter.writeEmptyElement("StudyDesc");
+//    xmlWriter.writeEmptyElement("SeriesDesc");
+//    xmlWriter.writeEmptyElement("OperatorName");
+//    xmlWriter.writeTextElement("OperatorComment", "NA");
+//    xmlWriter.writeEmptyElement("SegmentationDate");
+//    xmlWriter.writeTextElement("Inventor", "1");
+//    xmlWriter.writeEndElement(); // DIFHeader
+
+//    xmlWriter.writeStartElement("DIFBody");
+//    xmlWriter.writeStartElement("Volumes");
+//    xmlWriter.writeAttribute("number", QString::number(datasetList.size()));
+
+//    vtkMetaSurfaceMesh * metaSurface = 0;
+//    vtkSmartPointer<vtkIdList> pointIds = vtkIdList::New();
+//    double point[3];
+//    double * color;
+//    int final_colors[3];
+
+//    for (unsigned int j = 0; j<datasetList.size(); ++j)
+//    {
+//        vtkMetaDataSet* metadata = datasetList.at(j);
+
+//        if (metadata->GetType() != vtkMetaDataSet::VTK_META_SURFACE_MESH)
+//            continue;
+
+//        metaSurface = vtkMetaSurfaceMesh::SafeDownCast(metadata);
+
+//        xmlWriter.writeStartElement("Volume");
+//        xmlWriter.writeAttribute("name", QString(metadata->GetName()));
+
+//        QString colorHex;
+//        vtkActor * dataSetActor = metadata->GetActor(0);
+//        if (dataSetActor) {
+//            color = dataSetActor->GetProperty()->GetColor();
+//            final_colors[0] = int(color[0]*255);
+//            final_colors[1] = int(color[1]*255);
+//            final_colors[2] = int(color[2]*255);
+
+//            colorHex = QString::number(final_colors[0], 16) +
+//                               QString::number(final_colors[1], 16) +
+//                               QString::number(final_colors[2], 16);
+//        } else {
+//            colorHex = "FFFFFF";
+//        }
+
+//        xmlWriter.writeAttribute("color", colorHex);
+
+//        xmlWriter.writeStartElement("Vertices");
+//        xmlWriter.writeAttribute("number", QString::number(metaSurface->GetPolyData()->GetNumberOfPoints()));
+//        for(vtkIdType i = 0; i < metaSurface->GetPolyData()->GetNumberOfPoints(); ++i)
+//        {
+//            metaSurface->GetPolyData()->GetPoint(i, point);
+//            xmlWriter.writeCharacters(QString::number(point[0]) + " " +
+//                                      QString::number(point[1]) + " " +
+//                                      QString::number(point[2]) + "\n");
+//        }
+//        xmlWriter.writeEndElement(); // Vertices
+
+//        xmlWriter.writeStartElement("Polygons");
+//        xmlWriter.writeAttribute("number", QString::number(metaSurface->GetPolyData()->GetPolys()->GetNumberOfCells()));
+//        for(unsigned int i = 0; i<metaSurface->GetPolyData()->GetPolys()->GetNumberOfCells(); ++i)
+//        {
+//            metaSurface->GetPolyData()->GetCellPoints(i, pointIds);
+//            if (pointIds->GetNumberOfIds() != 3)
+//            {
+//                qDebug() << "navxVtkWriter: wrong type of cells !";
+//                return false;
+//            }
+//            xmlWriter.writeCharacters(QString::number(pointIds->GetId(0)+1) + " " +
+//                                      QString::number(pointIds->GetId(1)+1) + " " +
+//                                      QString::number(pointIds->GetId(2)+1) + "\n");
+//        }
+//        xmlWriter.writeEndElement(); // Polygons
+
+//        xmlWriter.writeEndElement(); //Volume
+//    }
+
+//    xmlWriter.writeEndElement(); // Volumes
+
+//    xmlWriter.writeStartElement("Labels");
+//    xmlWriter.writeAttribute("number", 0);
+//    xmlWriter.writeEndElement(); // Labels
+
+//    xmlWriter.writeStartElement("ObjectMap");
+//    xmlWriter.writeTextElement("Rotation", "0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000");
+//    xmlWriter.writeTextElement("Translation", "0 0 0");
+//    xmlWriter.writeTextElement("Scaling", "1 1 1");
+//    xmlWriter.writeTextElement("MD5Signature", "0");
+//    xmlWriter.writeEndElement(); // ObjectMap
+
+//    xmlWriter.writeEndElement(); // DIFBody
+
+//    xmlWriter.writeEndElement(); // DIF
+//    xmlWriter.writeEndDocument();
+
+//    difFile.close();
+
+    return true;
+}
+
+
+// /////////////////////////////////////////////////////////////////
+// Type instantiation
+// /////////////////////////////////////////////////////////////////
+
+dtkAbstractDataReader * navxDifReader::create()
+{
+    return new navxDifReader;
+}
diff --git a/src-plugins/cartoNavxReadersWriters/navxDifReader.h b/src-plugins/cartoNavxReadersWriters/navxDifReader.h
new file mode 100644
index 0000000..d207c7b
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/navxDifReader.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include <dtkCore/dtkAbstractDataReader.h>
+#include <cartoNavxReadersWritersPluginExport.h>
+
+class CARTONAVXREADERSWRITERSPLUGIN_EXPORT navxDifReader : public dtkAbstractDataReader
+{
+    Q_OBJECT
+
+public:
+    navxDifReader();
+    virtual ~navxDifReader();
+
+    virtual QString identifier() const;
+    virtual QString description() const;
+    virtual QStringList handled() const;
+
+    virtual QStringList supportedFileExtensions() const;
+
+    static bool registered();
+    static dtkAbstractDataReader * create();
+
+public slots:
+    virtual bool canRead(const QString &file);
+    virtual bool read(const QString &file);
+};
diff --git a/src-plugins/cartoNavxReadersWriters/navxDifWriter.cpp b/src-plugins/cartoNavxReadersWriters/navxDifWriter.cpp
new file mode 100644
index 0000000..79aa477
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/navxDifWriter.cpp
@@ -0,0 +1,222 @@
+#include <navxDifWriter.h>
+
+#include <dtkCore/dtkAbstractDataFactory.h>
+#include <dtkCore/dtkSmartPointer.h>
+
+#include <medAbstractData.h>
+
+#include <vtkMetaSurfaceMesh.h>
+#include <vtkPolyData.h>
+#include <vtkSmartPointer.h>
+#include <vtkErrorCode.h>
+#include <vtkCellArray.h>
+#include <vtkActor.h>
+#include <vtkProperty.h>
+
+#include <QXmlStreamWriter>
+
+// /////////////////////////////////////////////////////////////////
+// navxDifWriter
+// /////////////////////////////////////////////////////////////////
+
+navxDifWriter::navxDifWriter() : dtkAbstractDataWriter()
+{
+}
+
+
+navxDifWriter::~navxDifWriter()
+{
+}
+
+
+QString navxDifWriter::identifier() const
+{
+    return QString("navxDifWriter");
+}
+
+
+QString navxDifWriter::description() const
+{
+    return QString("Saint-Jude NavX .dif mesh exporter");
+}
+
+
+QStringList navxDifWriter::handled() const
+{
+    return QStringList() << "vtkDataMesh";
+}
+
+
+QStringList navxDifWriter::supportedFileExtensions() const
+{
+    return QStringList() << ".dif";
+}
+
+
+bool navxDifWriter::registered()
+{
+    return dtkAbstractDataFactory::instance()->registerDataWriterType("navxDifWriter", QStringList() << "vtkDataMesh", create);
+}
+
+
+bool navxDifWriter::canWrite(const QString & path)
+{
+    return path.endsWith(".dif");
+}
+
+
+bool navxDifWriter::write(const QString & path)
+{
+    dtkAbstractData * dtkData = this->data();
+
+    if ( ! dtkData || dtkData->identifier() != "vtkDataMesh") {
+        qDebug() << "navxDifWriter: No data provided, or wrong type";
+        return false;
+    }
+
+    vtkMetaSurfaceMesh * dataSet = dynamic_cast<vtkMetaSurfaceMesh*>( (vtkObject*)(dtkData->data()));
+    if ( ! dataSet) {
+        qDebug() << "navxDifWriter: not a vtkMetaSurfaceMesh";
+        return false;
+    }
+
+    QList<vtkMetaDataSet*> datasetList;
+    datasetList.push_back(dataSet); //TODO = this->Input->GetMetaDataSetList();
+
+
+    QFile difFile(path);
+    if ( ! difFile.open(QIODevice::WriteOnly) ) {
+        qDebug() << "navxDifWriter: Could not open file" << path;
+        return false;
+    }
+
+    QXmlStreamWriter xmlWriter(&difFile);
+
+    xmlWriter.setAutoFormatting(true);
+
+    xmlWriter.writeStartDocument();
+    xmlWriter.writeStartElement("DIF");
+
+    xmlWriter.writeStartElement("DIFHeader");
+    xmlWriter.writeTextElement("Version", "SJM_DIF_3.0");
+    xmlWriter.writeTextElement("VendorVersion", "NA");
+    xmlWriter.writeTextElement("PatientName", "NA");
+    xmlWriter.writeTextElement("PatientID", "NA");
+    xmlWriter.writeEmptyElement("PatientBirthDate");
+    xmlWriter.writeTextElement("PatientGender", "NA");
+    xmlWriter.writeEmptyElement("StudyID");
+    xmlWriter.writeEmptyElement("SeriesNumber");
+    xmlWriter.writeEmptyElement("StudyDate");
+    xmlWriter.writeEmptyElement("StudyTime");
+    xmlWriter.writeEmptyElement("SeriesTime");
+    xmlWriter.writeEmptyElement("Modality");
+    xmlWriter.writeEmptyElement("RefPhysName");
+    xmlWriter.writeEmptyElement("StudyDesc");
+    xmlWriter.writeEmptyElement("SeriesDesc");
+    xmlWriter.writeEmptyElement("OperatorName");
+    xmlWriter.writeTextElement("OperatorComment", "NA");
+    xmlWriter.writeEmptyElement("SegmentationDate");
+    xmlWriter.writeTextElement("Inventor", "1");
+    xmlWriter.writeEndElement(); // DIFHeader
+
+    xmlWriter.writeStartElement("DIFBody");
+    xmlWriter.writeStartElement("Volumes");
+    xmlWriter.writeAttribute("number", QString::number(datasetList.size()));
+
+    vtkMetaSurfaceMesh * metaSurface = 0;
+    vtkSmartPointer<vtkIdList> pointIds = vtkIdList::New();
+    double point[3];
+    double * color;
+    int final_colors[3];
+
+    for (unsigned int j = 0; j<datasetList.size(); ++j)
+    {
+        vtkMetaDataSet* metadata = datasetList.at(j);
+
+        if (metadata->GetType() != vtkMetaDataSet::VTK_META_SURFACE_MESH)
+            continue;
+
+        metaSurface = vtkMetaSurfaceMesh::SafeDownCast(metadata);
+
+        xmlWriter.writeStartElement("Volume");
+        xmlWriter.writeAttribute("name", QString(metadata->GetName()));
+
+        QString colorHex;
+        vtkActor * dataSetActor = metadata->GetActor(0);
+        if (dataSetActor) {
+            color = dataSetActor->GetProperty()->GetColor();
+            final_colors[0] = int(color[0]*255);
+            final_colors[1] = int(color[1]*255);
+            final_colors[2] = int(color[2]*255);
+
+            colorHex = QString::number(final_colors[0], 16) +
+                               QString::number(final_colors[1], 16) +
+                               QString::number(final_colors[2], 16);
+        } else {
+            colorHex = "FFFFFF";
+        }
+
+        xmlWriter.writeAttribute("color", colorHex);
+
+        xmlWriter.writeStartElement("Vertices");
+        xmlWriter.writeAttribute("number", QString::number(metaSurface->GetPolyData()->GetNumberOfPoints()));
+        for(vtkIdType i = 0; i < metaSurface->GetPolyData()->GetNumberOfPoints(); ++i)
+        {
+            metaSurface->GetPolyData()->GetPoint(i, point);
+            xmlWriter.writeCharacters(QString::number(point[0]) + " " +
+                                      QString::number(point[1]) + " " +
+                                      QString::number(point[2]) + "\n");
+        }
+        xmlWriter.writeEndElement(); // Vertices
+
+        xmlWriter.writeStartElement("Polygons");
+        xmlWriter.writeAttribute("number", QString::number(metaSurface->GetPolyData()->GetPolys()->GetNumberOfCells()));
+        for(unsigned int i = 0; i<metaSurface->GetPolyData()->GetPolys()->GetNumberOfCells(); ++i)
+        {
+            metaSurface->GetPolyData()->GetCellPoints(i, pointIds);
+            if (pointIds->GetNumberOfIds() != 3)
+            {
+                qDebug() << "navxVtkWriter: wrong type of cells !";
+                return false;
+            }
+            xmlWriter.writeCharacters(QString::number(pointIds->GetId(0)+1) + " " +
+                                      QString::number(pointIds->GetId(1)+1) + " " +
+                                      QString::number(pointIds->GetId(2)+1) + "\n");
+        }
+        xmlWriter.writeEndElement(); // Polygons
+
+        xmlWriter.writeEndElement(); //Volume
+    }
+
+    xmlWriter.writeEndElement(); // Volumes
+
+    xmlWriter.writeStartElement("Labels");
+    xmlWriter.writeAttribute("number", "0");
+    xmlWriter.writeEndElement(); // Labels
+
+    xmlWriter.writeStartElement("ObjectMap");
+    xmlWriter.writeTextElement("Rotation", "0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000");
+    xmlWriter.writeTextElement("Translation", "0 0 0");
+    xmlWriter.writeTextElement("Scaling", "1 1 1");
+    xmlWriter.writeTextElement("MD5Signature", "0");
+    xmlWriter.writeEndElement(); // ObjectMap
+
+    xmlWriter.writeEndElement(); // DIFBody
+
+    xmlWriter.writeEndElement(); // DIF
+    xmlWriter.writeEndDocument();
+
+    difFile.close();
+
+    return true;
+}
+
+
+// /////////////////////////////////////////////////////////////////
+// Type instantiation
+// /////////////////////////////////////////////////////////////////
+
+dtkAbstractDataWriter * navxDifWriter::create()
+{
+    return new navxDifWriter;
+}
diff --git a/src-plugins/cartoNavxReadersWriters/navxDifWriter.h b/src-plugins/cartoNavxReadersWriters/navxDifWriter.h
new file mode 100644
index 0000000..bb974ac
--- /dev/null
+++ b/src-plugins/cartoNavxReadersWriters/navxDifWriter.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include <dtkCore/dtkAbstractDataWriter.h>
+#include <cartoNavxReadersWritersPluginExport.h>
+
+class CARTONAVXREADERSWRITERSPLUGIN_EXPORT navxDifWriter : public dtkAbstractDataWriter
+{
+    Q_OBJECT
+
+public:
+    navxDifWriter();
+    virtual ~navxDifWriter();
+
+    virtual QString identifier() const;
+    virtual QString description() const;
+    virtual QStringList handled() const;
+
+    virtual QStringList supportedFileExtensions() const;
+
+    static bool registered();
+    static dtkAbstractDataWriter * create();
+
+public slots:
+    virtual bool canWrite(const QString &file);
+    virtual bool write(const QString &file);
+};
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/CMakeLists.txt b/src-plugins/libs/vtkInria/vtkDataManagement/CMakeLists.txt
index da9e8cc..e464a09 100644
--- a/src-plugins/libs/vtkInria/vtkDataManagement/CMakeLists.txt
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/CMakeLists.txt
@@ -24,12 +24,22 @@ set(vtkDataManagement_SRCS
   vtkMetaVolumeMesh.cxx
   vtkDataManager.cxx
   vtkMetaDataSetSequence.cxx
-  vtkDiffXMLWriter.cxx
   vtkFiberDataSet.cxx
   vtkXMLFiberDataSetReader.cxx
   vtkXMLFiberDataSetWriter.cxx
+  vtkDiffXMLReader.cxx
+  vtkCardioInsightDataReader.cxx
+  CPPXMLReader.cxx
+  XMLToVTKObject.cxx
 )
 
+# We need to use some functions from vtkVisuManagement, but can't link to it
+# because that would be a circular dependency. So instead, allow undefined symbols
+if (APPLE)
+  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -undefined dynamic_lookup")
+ENDIF()
+
+
 if (VTK_MAJOR_VERSION GREATER 4)
   if (VTK_MINOR_VERSION GREATER 0)
     set(${PROJECT_NAME}_SRCS
@@ -65,6 +75,7 @@ set(${PROJECT_NAME}_LIBS
   vtkImaging
   vtkIO
   vtkRendering
+  vtkInfovis
   itkIOAddOn
   ITKVTK
   # ITK4 IO libs
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/CPPXMLReader.cxx b/src-plugins/libs/vtkInria/vtkDataManagement/CPPXMLReader.cxx
new file mode 100644
index 0000000..f2c606a
--- /dev/null
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/CPPXMLReader.cxx
@@ -0,0 +1,408 @@
+#include "CPPXMLReader.h"
+#include <iostream>
+#include <string.h>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <cstdlib>
+
+using namespace std;
+
+
+string space2underscore(string text, int pos)
+{
+	int length = text.size();
+	int x = 0;
+	string fixed;
+	
+	while (x != length) {
+        string letter = text.substr(x, pos+1);
+        if (letter == " ") {
+			letter = "_";}
+        fixed = fixed + letter;
+        x = x + 1;
+	}
+	
+	return fixed;
+}
+
+/* xmlObject */
+// constructor for xmlObject, if any details are passed whilst constructing 
+xmlObject::xmlObject(string tag, string tValue, xmlAttribute attribute)
+{
+	_tagName = tag;
+	_tagValue.clear();
+	_attributes.push_back(attribute);
+	_isComplete = false; 
+	_children.clear();
+	_tagValueText="";
+}
+
+// xml <tagname attributes="attributesvalue">VALUE</tagname>
+// set the tag name
+void xmlObject::setTagName(string tagName)
+{
+	_tagName = tagName;
+}
+
+// set tag value
+void xmlObject::setTagValue(string tagValue)
+{
+	_tagValue.push_back(tagValue);
+}
+
+// add attributes to the vector attributes variable
+void xmlObject::addAttributes(xmlAttribute attribute)
+{
+	_attributes.push_back(attribute);
+}
+
+// fill in the vector attributes variable.
+void xmlObject::setAttributeVector(vector<xmlAttribute> setAtt)
+{
+	_attributes = setAtt;
+}
+
+// print out the xml object detais, with the attributes values.
+void xmlObject::printOutXmlObject(ostream& os)
+{
+	os << "XML Object" << endl;
+	os << "Tagname  :" << _tagName << endl;
+	os << "Tagvalue size :" << _tagValue.size() << endl;
+//	for (int i= 0; i < (int)_tagValue.size(); i++)
+//		os << "Tagvalue :" << _tagValue[i] << endl;
+	for (int i= 0; i < (int)_attributes.size(); i++)
+	{
+		os << "Attribute " << i << " : Name : "<< _attributes.at(i)._attributeName << " Value : " << _attributes.at(i)._attributeValue << endl;
+	}
+}
+
+// set the main set details value
+void xmlObject::setXmlMainDetails(bool value)
+{	
+    _xmlMainDetails = value;
+}
+
+// get a boolean value to see if the xmlObject is the main <?xml .. ?> value
+bool xmlObject::getXmlMainDetails()
+{
+	return _xmlMainDetails;
+}
+
+// set the tag values
+void xmlObject::setTagValuesFromText(string _text)
+{
+	this->setTagValuesText(_text);
+	
+	istringstream iss(_text);
+	string subLine;
+	do
+	{
+		iss >> subLine;
+		this->setTagValue(subLine);
+	} while (iss);
+}
+
+
+//int xmlObject::getNumberOfChildrenWithSameName(string _childName)
+//{
+//	int nameOccurence=0;
+//	for (int cc=0; cc<(_children.size()); cc++) 
+//		if(_childName==(_children[cc]->getTagName()))
+//			nameOccurence++;
+//	
+//	return nameOccurence;
+//}
+
+
+
+
+/*xmlReader*/
+xmlReader::xmlReader()
+{
+}
+
+// attribute is normally in the format of attributeName="attributeValue"
+xmlAttribute xmlReader::getAttribute(string attributeString)
+{
+	xmlAttribute returnAttribute;
+	
+	// make sure that there is a = in the attribute string
+	int findEqual = attributeString.find('=');
+	if (findEqual > 0)
+	{
+		// set the attribute name to the substring till the equal
+		returnAttribute._attributeName = attributeString.substr(0,findEqual);
+		// make sure that there is some characters after the '=' sign.
+		if (attributeString.length() > (findEqual+3))
+		{
+			returnAttribute._attributeValue = attributeString.substr(findEqual+2,(attributeString.length() - (findEqual +3)));
+		}
+		else
+			throw BADATTRIBUTE;
+	}else
+		// if there does not appear to be ="" at the end of the string then throw a error.
+		throw BADATTRIBUTE;
+	
+	return returnAttribute;
+}
+
+vector<xmlAttribute> xmlReader::getAttributesFromString(string str)
+{
+    vector<xmlAttribute> returnAtt;
+    xmlAttribute attribute;
+    int args;
+    char st1[CHARACTERLENGHT];
+	
+    // args normally equals 1 because there is a attribute present
+    // else there was no attribute there, just do one at a time
+
+	// put underscores in the spaces for attribute value
+	string str2 = space2underscore(str.substr(1),0);
+	
+//    args = sscanf(str.c_str(), "%s", st1);
+	args = sscanf(str2.c_str(), "%s", st1);
+	
+    while (args  == 1 && (str.length() > 1)) {
+		// see if there is a real attribute attributeName="attributeValue"
+		try {
+			attribute = xmlReader::getAttribute(st1);
+			// push back in the vector array the attribute
+			returnAtt.push_back(attribute);
+		} catch (string errorStr)		// any errors
+		{
+			cout << "ERROR : " << errorStr << endl;
+		}
+		// re-do the string to pull out any more attributes.
+		str = str.substr(strlen(st1));
+		// see if there is any more attributes present.
+		args = sscanf(str.c_str(), "%s", st1);
+    }
+    return returnAtt;
+}
+
+// scan through the xml string and pull out the tags and the attributes and value.
+xmlObject* xmlReader::readLine(string xmlToSplitUp, string* tagName)
+{
+	xmlObject* returnObj = NULL;
+	string returnLine, value, endTagName;
+	int findXml;
+	
+	// pick out the tag name, if none then return and throw a bad tag name error.
+//	std::cout<<"xmlToSplitUp : "<<xmlToSplitUp<<std::endl;
+	*tagName = xmlReader::readUntilCharacter(xmlToSplitUp, '<','>', &returnLine);
+//	std::cout<<"returnLine : "<<returnLine<<std::endl;
+	if (tagName->length() ==0)
+	{
+		//throw BADTAGNAME;
+		return NULL;
+	}
+	
+	// if there is a xml version etc in the tagname then process the xml version encoding values.
+	findXml=tagName->find("xml");
+	if ((findXml > 0 && findXml < tagName->length()) && tagName->length() > 1 )
+	{
+		// this is the xml version etc.
+		// there should be ? at each end of the xml version statement
+		string xmlStr = xmlReader::readUntilCharacter(*tagName, '?','?', &returnLine);
+		if (returnLine != "?") 
+		{
+			throw BADXMLVERSION;
+			return NULL;
+		}
+		// go passed the xml characters.
+		returnLine = xmlStr.substr(findXml+3);
+		
+		returnObj = new xmlObject();
+		// read any of the attributes from the string
+		returnObj->setAttributeVector(xmlReader::getAttributesFromString(returnLine));
+		// I am storing the version and any other xml details, so set the return value to store in the correct place.
+		returnObj->setXmlMainDetails(true);
+	}else if (tagName->length() > 1) 
+	{
+		returnObj = new xmlObject();
+		returnObj->setRawTagName(*tagName);
+		
+		// need to see if there is any attributes
+		int findTagAtts = tagName->find(' ');
+		if (findTagAtts < tagName->length())
+		{
+			// the attributes are passed the space character in the tagName variable
+			string attributes = tagName->substr(findTagAtts);
+			
+			std::cout<<"attributes xmlReader::readLine" << attributes<<"\n";
+			// store only the tagName in the tagName variable since pulled out the attributes
+			*tagName = tagName->substr(0,findTagAtts);
+			// get the attributes into a vector and store in the return object
+			returnObj->setAttributeVector(xmlReader::getAttributesFromString(attributes));
+		}
+		
+		if (returnLine.length() > 1)
+		{
+			// pull out the value in the xml line <tagname>VALUE</tagname>
+			
+			value = xmlReader::readUntilCharacter(returnLine,'>','<',&returnLine);
+			//std::cout<<"value : "<<value<<std::endl;
+			returnObj->setTagValue(value);
+			returnObj->setCompleted(true);
+		}
+		if (returnLine.length() > 1)
+		{
+			// pick out the end tag name and make sure it is the same as the first one.
+			endTagName = xmlReader::readUntilCharacter(returnLine,'<','>',&returnLine);
+			string compareEndTag = "/"+*tagName;
+			//if the end tag is not the same as the tag name then throw a error.
+			if (endTagName != compareEndTag) 
+			{
+				throw BADXMLTAGEND;
+			} 
+		}
+		returnObj->setTagName(*tagName);
+		
+	}
+	return returnObj;
+}
+
+// pick out the characters between two character points, and also return the rest of the line.
+string xmlReader::readUntilCharacter(string line, char characterStart, char characterEnd, string *returnLine)
+{
+	string returnString;
+	// find the first occurrence of the character integer placement
+	int firstChar = line.find(characterStart);
+	// if there is one.
+	if (firstChar >= 0)
+	{
+		// setup the return string, even if a second part cannot be found.
+		returnString = line.substr(firstChar+1, (line.length()- firstChar)-1);
+		int secChar = returnString.find(characterEnd);
+		//if the secound part can be found
+		if (secChar > 0)
+		{
+			*returnLine = returnString.substr(secChar, (returnString.length() - secChar));
+			returnString = returnString.substr(0,secChar);
+		}
+	}
+	return returnString;
+}
+
+// pick the text between the start and end of the tagname, 
+string xmlReader::getTextInBetween(string filename,string rawTagName, size_t* end_position, size_t start_position, size_t search_position)
+{
+	string Text="";
+	string WholeFile = filename;
+	
+	if(WholeFile!="")
+	{
+		size_t start_pos, stop_pos;
+		
+		string startTagName = "<"+rawTagName+">";
+		start_pos = WholeFile.find(startTagName,start_position);
+		
+		// convert from raw (with attributes) to proper (without attributes)
+		string tagName = rawTagName;
+		int findTagAtts = rawTagName.find(' ');
+		if (findTagAtts < rawTagName.length())
+			tagName = rawTagName.substr(0,findTagAtts);
+		
+		string endTagName = "</"+tagName+">";
+		stop_pos = WholeFile.find(endTagName,search_position);
+		
+		if(start_pos<stop_pos)
+		{
+			size_t length_substr = stop_pos - (start_pos+startTagName.length());
+			Text = WholeFile.substr (start_pos+startTagName.length(),length_substr);
+			
+			*end_position = stop_pos+(endTagName.length());
+		}
+		else
+		{
+			Text=xmlReader::getTextInBetween(WholeFile,rawTagName,end_position,start_pos,stop_pos+1);
+			
+		}
+	}
+	return Text;
+}
+
+// read in the XML file and place each line into the vector xmlObject 
+bool xmlReader::loadFile(string filename)
+{
+	xmlObject* xmlObj = NULL;
+	string line, tagName;
+	char * pch;
+	
+	ifstream xmlfile(filename.c_str());
+	if (xmlfile.is_open())
+	{
+		// if the xml version and also the encodingvalues are present.
+		//getline(xmlfile,line);
+		
+		while (!xmlfile.eof())
+		{
+			std::cout<<"out here"<<std::endl;
+			// pull out the start tag and compare against the endtag
+			getline(xmlfile,line);
+			try 
+			{
+				std::cout<<"in here"<<std::endl;
+				// pick out the xml details from line and return a xmlObject 
+				// to add to the vector array of xml objects
+				// also return the tagName if any futher processing is required.
+				xmlObj = xmlReader::readLine(line, &tagName);
+				
+				if(!xmlObj)
+				{
+					if(tagName=="Vertices")
+					{
+						//std::cout<<"vlaeie: "<<xmlObj.getAttributeVector()[0].getAttributeValue()<<std::endl;
+						int No=atoi((xmlObj->getAttributeVector()[0]).getAttributeValue().c_str()); 
+						No=1;
+						for(int i=0;i<No;i++)
+						{
+							getline(xmlfile,line);
+							pch = strtok ((char*)line.c_str()," ");
+							while (pch != NULL)
+							{
+								printf ("%s\n",pch);
+								pch = strtok (NULL, " ");
+							}
+						}
+					}
+					
+					
+					// if there is ?xml version etc details present store, else store into the main xml details
+					if (xmlObj->getXmlMainDetails())
+					{
+						_xmlMainDetails.push_back(*xmlObj);
+					}
+					else
+					{  
+						_xmlDetails.push_back(*xmlObj);
+					}
+				}
+			}
+			// if any error occur during the reading of the xml line.
+			catch (string errorStr)
+			{
+				cout << "ERROR : " << errorStr << endl;
+			}
+		}
+		
+		xmlfile.close();
+	}
+	else
+	{
+		cout << "Unable to open the file" << endl;
+	}
+}
+
+/* print Out the outer XML values */
+void xmlReader::printOuterXML(ostream& os)
+{
+    cout << "XML Reader Main Object (Xml main details) " << endl;
+    for (int i =0; i < _xmlMainDetails.size(); i++)
+		_xmlMainDetails.at(i).printOutXmlObject(os);
+	
+    cout << "XML Reader xml details" << endl;
+    for (int i =0; i < _xmlDetails.size(); i++)
+		_xmlDetails.at(i).printOutXmlObject(os);
+}
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/CPPXMLReader.h b/src-plugins/libs/vtkInria/vtkDataManagement/CPPXMLReader.h
new file mode 100644
index 0000000..29c2a68
--- /dev/null
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/CPPXMLReader.h
@@ -0,0 +1,94 @@
+#ifndef CPPXMLREADER_H
+#define CPPXMLREADER_H
+
+#include <string>
+#include <vector>
+
+// using the namespace std for the string type, vector
+using namespace std;
+
+
+const int CHARACTERLENGHT = 80;
+const std::string BADXMLVERSION = "Xml version - first line ? - problem";
+const std::string BADTAGNAME = "Tag name was not present";
+const std::string BADXMLTAGEND = "End tag is not the same as tag name";
+const std::string BADATTRIBUTE = "Attribute in wrong format attributeName=\"attributeValue\"";
+
+string space2underscore(string text, int pos);
+
+struct xmlAttribute {
+	std::string _attributeName, _attributeValue;
+	
+	string getAttributeValue(){return _attributeValue;};
+	string getAttributeName(){return _attributeName;};
+};
+
+class xmlObject {
+	private :
+    string _rawTagName,_tagName,_tagValueText;
+	vector<string> _tagValue;
+    vector<xmlAttribute> _attributes;
+    bool _xmlMainDetails;
+	bool _isComplete;
+	size_t _lastPosition;
+	
+	vector<xmlObject*> _children;
+	
+public:
+	xmlObject() { _rawTagName="";_tagName = ""; _tagValue.clear(); _xmlMainDetails = false; _isComplete = false;_lastPosition=0;};
+	xmlObject(string tag, string tValue, xmlAttribute attribute);
+	
+	void setTagName(string tagName);
+	string getTagName(void) {return _tagName;};
+	
+	void setRawTagName(string tagName){ _rawTagName=tagName;};
+	string getRawTagName(void) {return _rawTagName;};
+	
+	vector<string> getTagValue(void) {return _tagValue;};
+	void setTagValue(string tagValue);
+	void addAttributes(xmlAttribute attribute);
+	void setAttributeVector(vector<xmlAttribute> setAtt);
+	vector<xmlAttribute> getAttributeVector(){return _attributes;};
+	
+	void setXmlMainDetails(bool value);
+	bool getXmlMainDetails();
+	void printOutXmlObject(ostream& os);
+	void setChild(xmlObject* child){_children.push_back(child);};
+	
+	vector<xmlObject*> getChildren(){ return _children;};
+	
+	bool isCompleted(){return _isComplete;};
+	void setCompleted(bool flag){_isComplete = flag;};
+	
+	void setTagValuesFromText(string _text);
+//	int getNumberOfChildrenWithSameName(string _childName);
+	
+	void setTagValuesText(string _text){_tagValueText = _text;};
+	string getTagValueText(){return _tagValueText;};
+	
+	void setLastPosition(size_t _pos){_lastPosition = _pos;};
+	size_t getLastPosition(){return _lastPosition;};
+};
+
+class xmlReader {
+protected:
+    vector<xmlObject> _xmlMainDetails;
+    vector<xmlObject> _xmlDetails;
+	
+public: 
+    xmlReader();
+	
+    // open file and read in the xml file and place into the _xmlDetails
+    bool loadFile(string filename);
+    void printOuterXML(ostream& os);
+	
+	static xmlObject* readLine(string xmlToSplitUp, string* tagName);
+	static string readUntilCharacter(string line, char characterStart, char characterEnd, string *returnLine);
+	static xmlAttribute getAttribute(string attributeString);
+    static vector<xmlAttribute> getAttributesFromString(string str);
+	
+	static string getTextInBetween(string FILE,string tagName, size_t* end_position, size_t start_position=0, size_t search_position=0);
+};
+
+
+#endif // CPPXMLREADER_H
\ No newline at end of file
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/XMLToVTKObject.cxx b/src-plugins/libs/vtkInria/vtkDataManagement/XMLToVTKObject.cxx
new file mode 100644
index 0000000..2c38dfc
--- /dev/null
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/XMLToVTKObject.cxx
@@ -0,0 +1,514 @@
+#include "XMLToVTKObject.h"
+#include <iostream>
+#include <string.h>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <vtkFloatArray.h>
+#include <vtkCellArray.h>
+#include <vtkUnsignedShortArray.h>
+#include <vtkPointData.h>
+#include <vtkCellData.h>
+#include <vtkPolyDataWriter.h>
+#include <vtkDoubleArray.h>
+#include <vtkLookupTable.h>
+#include <vtkVectorText.h>
+#include <vtkSphereSource.h>
+#include <vtkMatrix4x4.h>
+#include <vtkMatrixToLinearTransform.h>
+#include <vtkProbeFilter.h>
+
+#include "vtkLookupTableManager.h"
+
+using namespace std;
+
+// constructors
+XMLToVTKObject::XMLToVTKObject(xmlObject* _obj)
+{
+	_xmlObj = _obj;
+	_vtkPolygonalVolumes = NULL;
+}
+
+XMLToVTKObject::XMLToVTKObject()
+{
+	_xmlObj = NULL;
+	_vtkPolygonalVolumes = NULL;
+}
+
+XMLToVTKObject::~XMLToVTKObject()
+{
+	if(_xmlObj)
+		delete _xmlObj;
+	if(_vtkPolygonalVolumes)
+		_vtkPolygonalVolumes->Delete();
+}
+
+
+void XMLToVTKObject::Update()
+{
+	if(!_xmlObj)
+		return;
+
+	if(_xmlObj->getTagName() == "DIF") 
+		this->CreateFromDIF_XML(_xmlObj);
+	
+}
+
+
+void XMLToVTKObject::CreateFromDIF_XML(xmlObject* _parentObj)
+{
+	xmlObject* _childObj;
+	_vtkPolygonalVolumes = vtkAppendPolyData::New();
+//	_vtkLabels = vtkPolyData::New();
+	
+	for(int cc=0;cc<_xmlObj->getChildren().size();cc++)
+	{
+		_childObj = (_xmlObj->getChildren())[cc];
+		
+		if(_childObj->getTagName() == "DIFBody") 
+				this->CreateVolumes(_childObj,_vtkPolygonalVolumes);
+	}
+	
+	
+}
+								
+
+void XMLToVTKObject::CreateVolumes(xmlObject* _parentObj, vtkAppendPolyData* polyObjects)
+{
+	xmlObject* _childObj;
+	int NumberOfVolumes=0,NumberOfPointLabels=0;
+	vtkPolyData* polyObject=NULL;
+	vtkAppendPolyData* labelObjects=NULL;
+	
+	for(int cc=0;cc<_parentObj->getChildren().size();cc++)
+	{
+		_childObj = (_parentObj->getChildren())[cc];
+		
+		if(_childObj->getTagName() == "Volumes")	
+		{
+			NumberOfVolumes=atoi((_childObj->getAttributeVector()[0]).getAttributeValue().c_str()); 
+			for(int volNo=0;volNo<NumberOfVolumes;volNo++)
+			{
+				polyObject=vtkPolyData::New();
+				this->CreateVolume(_childObj,polyObject);
+				polyObjects->AddInput(polyObject);
+			}
+		}
+		
+		if(_childObj->getTagName() == "Labels")
+		{
+			NumberOfPointLabels=atoi((_childObj->getAttributeVector()[0]).getAttributeValue().c_str());
+			
+			for(int lblNo=0;lblNo<NumberOfPointLabels;lblNo++)
+			{
+				labelObjects=vtkAppendPolyData::New();
+				this->CreateLabel(_childObj,labelObjects);
+				
+				if(polyObject!=NULL)
+				{
+					vtkProbeFilter* probe = vtkProbeFilter::New();
+					probe->SetInput(labelObjects->GetOutput());
+					probe->SetSource(polyObject);
+					probe->SpatialMatchOn();
+					probe->Update();
+					
+					polyObjects->AddInput(probe->GetPolyDataOutput());
+				}
+				else 
+				{
+					polyObjects->AddInput(labelObjects->GetOutput());
+				}
+			}
+		}
+	}
+	
+	polyObjects->Update();
+	
+//			vtkPolyDataWriter* pdw = vtkPolyDataWriter::New();
+//			pdw->SetInput( polyObjects->GetOutput());
+//			pdw->SetFileName("/Users/jrelan/Desktop/check.vtk");
+//			
+//			pdw->Update();
+//			pdw->Delete();
+	
+}
+
+
+void XMLToVTKObject::CreateVolume(xmlObject* _parentObj, vtkPolyData* polyObject)
+{
+	xmlObject* _childObj;
+	string NameOfVolume,ColorOfVolume;
+	NameOfVolume="";
+	ColorOfVolume="";
+	
+	for(int cc=0;cc<_parentObj->getChildren().size();cc++)
+	{
+		_childObj = (_parentObj->getChildren())[cc];
+		
+		
+		if(_childObj->getTagName() == "Volume") 
+		{
+			for(int volAttr=0;volAttr<_childObj->getAttributeVector().size();volAttr++)
+			{
+				if ((_childObj->getAttributeVector()[volAttr]).getAttributeName() == "name")
+					NameOfVolume = (_childObj->getAttributeVector()[volAttr]).getAttributeValue();
+				if ((_childObj->getAttributeVector()[volAttr]).getAttributeName() == "color")
+					ColorOfVolume = (_childObj->getAttributeVector()[volAttr]).getAttributeValue();
+			}
+			//				polyObject->SetName();
+			//				polyObject->SetColor();
+			
+			std::cout<<"NameOfVolume "<<NameOfVolume<<std::endl;
+			std::cout<<"ColorOfVolume "<<ColorOfVolume<<std::endl;
+			
+			this->CreateVolume(_childObj,polyObject);
+		}
+		
+		
+		if(_childObj->getTagName() == "Vertices") 
+		{
+			int NumberOfVertices=atoi((_childObj->getAttributeVector()[0]).getAttributeValue().c_str());
+			
+			vtkPoints *points=vtkPoints::New();
+			points->SetNumberOfPoints (NumberOfVertices);
+			
+			int VertexNum=0;
+			float vTuple[3]; 
+			
+			istringstream iss(_childObj->getTagValueText());
+			while (VertexNum<NumberOfVertices)
+			{
+				iss >> vTuple[0];
+				iss >> vTuple[1];
+				iss >> vTuple[2];
+				
+				points->SetPoint (VertexNum, vTuple[0], vTuple[1], vTuple[2]);
+				
+				VertexNum++;
+			}
+			polyObject->SetPoints(points);
+			points->Delete();
+			
+			//				this->CreateVolume(_childObj,polyObject);
+		}
+		
+		
+		if(_childObj->getTagName() == "Polygons")
+		{
+			int NumberOfPolygons=atoi((_childObj->getAttributeVector()[0]).getAttributeValue().c_str());
+			
+			polyObject->Allocate (NumberOfPolygons);
+			
+			
+			int PolyNum=0,tx=0,ty=0,tz=0;
+			
+			istringstream iss(_childObj->getTagValueText());
+			while (PolyNum<NumberOfPolygons)
+			{
+				unsigned int ids[3];
+				iss >> ids[0];
+				iss >> ids[1];
+				iss >> ids[2];
+				
+				vtkIdList* idlist = vtkIdList::New();
+				idlist->InsertNextId (ids[0]-1);
+				idlist->InsertNextId (ids[1]-1);
+				idlist->InsertNextId (ids[2]-1);
+				
+				polyObject->InsertNextCell (VTK_TRIANGLE, idlist);
+				idlist->Delete();
+
+				PolyNum++;
+			}
+			
+			//				this->CreateVolume(_childObj,polyObject);
+		}
+		
+		
+		if(_childObj->getTagName() == "Normals") 
+		{ 
+			int NumberOfPolygonNormals=atoi((_childObj->getAttributeVector()[0]).getAttributeValue().c_str());
+			
+			vtkFloatArray* normalsArray = vtkFloatArray::New();
+			normalsArray->Allocate (NumberOfPolygonNormals);
+			normalsArray->SetNumberOfComponents(3);
+			
+			int PolyNormalsNum=0;
+			
+			istringstream iss(_childObj->getTagValueText());
+			while (PolyNormalsNum<NumberOfPolygonNormals)
+			{
+				float ids[3];
+				iss >> ids[0];
+				iss >> ids[1];
+				iss >> ids[2];
+				
+				normalsArray->InsertNextTuple(ids);
+				PolyNormalsNum++;
+			}
+			
+			if (polyObject->GetPointData())
+				polyObject->GetPointData()->SetNormals(normalsArray);
+			
+			normalsArray->Delete();
+			
+			
+			//				this->CreateVolume(_childObj,polyObject);
+		}
+		
+		
+		if(_childObj->getTagName() == "Surface_of_origin" || _childObj->getTagName() == "Map_data" || _childObj->getTagName() == "Map_status") 
+		{ 
+			int Number=atoi((_childObj->getAttributeVector()[0]).getAttributeValue().c_str());
+			
+			vtkDoubleArray* _Array = vtkDoubleArray::New();
+			_Array->Allocate (Number);
+			_Array->SetName ((_childObj->getTagName()).c_str());
+			
+			int cc=0;
+			
+			istringstream iss(_childObj->getTagValueText());
+			while (cc<Number)
+			{
+				double ids;
+				iss >> ids;
+				
+				_Array->InsertNextValue(ids);
+				cc++;
+			}
+			
+			if(Number == polyObject->GetNumberOfPolys())
+			{
+				if (polyObject->GetCellData())
+					polyObject->GetCellData()->AddArray(_Array);
+			}
+			
+			if(Number == polyObject->GetNumberOfPoints())
+			{
+				if (polyObject->GetPointData())
+					polyObject->GetPointData()->AddArray(_Array);
+			}
+			_Array->Delete();
+		}
+		
+		if(_childObj->getTagName() == "Map_color") 
+		{ 
+			int Number=atoi((_childObj->getAttributeVector()[0]).getAttributeValue().c_str());
+			
+			vtkDoubleArray* _Array = vtkDoubleArray::New();
+			_Array->Allocate (Number);
+			_Array->SetName ((_childObj->getTagName()).c_str());
+			
+			int cc=0;
+			
+			istringstream iss(_childObj->getTagValueText());
+			while (cc<Number)
+			{
+				double ids;
+				iss >> ids;
+				
+				_Array->InsertNextValue(ids);
+				cc++;
+			}
+			
+			
+			if(Number == polyObject->GetNumberOfPoints())
+			{
+				if (polyObject->GetPointData())
+					polyObject->GetPointData()->SetScalars(_Array);
+			}
+			_Array->Delete();
+		}
+		
+		if(_childObj->getTagName() == "Color_high_low") 
+		{ 
+			if(polyObject->GetPointData()->GetScalars())
+				if(!(polyObject->GetPointData()->GetScalars()->GetLookupTable()))
+						polyObject->GetPointData()->GetScalars()->SetLookupTable(vtkLookupTableManager::GetLONILookupTable());
+																		  
+			double colorRange[2];
+			int cc=0;
+			istringstream iss(_childObj->getTagValueText());
+			while (cc<1)
+			{
+				
+				iss >> colorRange[0];
+				iss >> colorRange[1];
+				
+				cc++;
+			}
+			
+			polyObject->GetPointData()->GetScalars()->GetLookupTable()->SetTableRange(colorRange);
+			
+			
+		
+		}
+		
+	}
+	
+	polyObject->Update();
+//	//polyObject->Print(std::cout);
+//	//	this->MapScalars(_childObj,polyObject);
+//	
+//	vtkPolyDataWriter* pdw = vtkPolyDataWriter::New();
+//	pdw->SetInput( polyObject);
+//	pdw->SetFileName("/Users/jrelan/Desktop/check.vtk");
+//	
+//	pdw->Update();
+//	pdw->Delete();
+
+}
+
+void XMLToVTKObject::CreateLabel(xmlObject* _parentObj, vtkAppendPolyData* polyObjects)
+{
+	xmlObject* _childObj;
+	string NameOfLabel,ColorOfLabel;
+	NameOfLabel=".";
+	ColorOfLabel="";
+	
+	for(int cc=0;cc<_parentObj->getChildren().size();cc++)
+	{
+		_childObj = (_parentObj->getChildren())[cc];
+		
+		
+		
+		if(_childObj->getTagName() == "Label") 
+		{
+			for(int volAttr=0;volAttr<_childObj->getAttributeVector().size();volAttr++)
+			{
+				if ((_childObj->getAttributeVector()[volAttr]).getAttributeName() == "name")
+					NameOfLabel = (_childObj->getAttributeVector()[volAttr]).getAttributeValue();
+				if ((_childObj->getAttributeVector()[volAttr]).getAttributeName() == "color")
+					ColorOfLabel = (_childObj->getAttributeVector()[volAttr]).getAttributeValue();
+			}
+			
+			std::cout<<"NameOfLabel "<<NameOfLabel<<std::endl;
+			std::cout<<"ColorOfLabel "<<ColorOfLabel<<std::endl;
+						
+			
+			
+			
+//			ofstream out_FILE;
+//			out_FILE.open("/Users/jrelan/Desktop/check.particles",ios_base::app);
+			
+//			vtkPolyData* polyObject=vtkPolyData::New();
+//			vtkPoints *points=vtkPoints::New();
+//			vtkCellArray *conn = vtkCellArray::New();
+//			
+//			points->SetNumberOfPoints(1);
+			
+//			float vTuple[3]; 
+//			int VertexNum=0;
+//			istringstream iss(_childObj->getTagValueText());
+//			while (VertexNum<1)
+//			{
+//				iss >> vTuple[0];
+//				iss >> vTuple[1];
+//				iss >> vTuple[2];
+//				
+////				out_FILE << vTuple[0] << " " << vTuple[1] << " " << vTuple[2] << "\n";
+//				points->SetPoint (VertexNum, vTuple[0], vTuple[1], vTuple[2]);
+//				conn->InsertNextCell(1, &VertexNum);
+//				
+//				VertexNum++;
+//			}
+//			polyObject->SetPoints(points);
+//			points->Delete();
+//			
+//			polyObject->SetVerts (conn);
+//			conn->Delete();
+//			
+//			polyObject->Update();
+						
+//			polyObjects->AddInput(polyObject);
+//			polyObject->Delete();
+			
+			
+			
+			float vTuple[3]; 
+			int VertexNum=0;
+			istringstream iss(_childObj->getTagValueText());
+			while (VertexNum<1)
+			{
+				iss >> vTuple[0];
+				iss >> vTuple[1];
+				iss >> vTuple[2];
+
+				vtkSphereSource* sphere = vtkSphereSource::New();
+				sphere->SetCenter(vTuple[0], vTuple[1], vTuple[2]);
+				sphere->SetRadius(3.0);
+				sphere->Update();
+				
+				polyObjects->AddInput(sphere->GetOutput());
+				sphere->Delete();
+
+				
+				vtkVectorText* label = vtkVectorText::New();
+				label->SetText(NameOfLabel.c_str());
+				label->Update();
+				
+				vtkMatrix4x4* tansformmatrix = vtkMatrix4x4::New();
+				for (int i=0;i<4;i++)
+				{
+					for (int j=0;j<4;j++)
+					{
+						tansformmatrix->SetElement(i,j,0);
+					}
+				}
+				// scaling the text
+				double scale=1.0;
+				scale=5.0;
+				
+				tansformmatrix->SetElement(0, 0, scale*1);
+				tansformmatrix->SetElement(1, 1, scale*1);
+				tansformmatrix->SetElement(2, 2, scale*1);
+				
+				tansformmatrix->SetElement(0, 3, vTuple[0]+3.0);
+				tansformmatrix->SetElement(1, 3, vTuple[1]+3.0);
+				tansformmatrix->SetElement(2, 3, vTuple[2]+3.0);
+				
+				
+				vtkMatrixToLinearTransform* Transform = vtkMatrixToLinearTransform::New();
+				Transform->SetInput (tansformmatrix);
+				
+				vtkPoints* Points = vtkPoints::New();
+				Points->Initialize();
+				
+				Transform->TransformPoints (label->GetOutput()->GetPoints(), Points);
+				Transform->Update();
+				
+				vtkPolyData* output = vtkPolyData::New();
+				output->DeepCopy (label->GetOutput());
+				output->GetPoints()->DeepCopy (Points);  
+				
+				
+				polyObjects->AddInput(output);
+				output->Delete();
+				Points->Delete();
+				Transform->Delete();
+				tansformmatrix->Delete();
+				label->Delete();
+				
+				
+				VertexNum++;
+			}
+			
+//			out_FILE.close();
+		}
+	}
+	
+	polyObjects->Update();
+//    polyObjects->Print(std::cout);
+	
+	
+//	vtkPolyDataWriter* pdw = vtkPolyDataWriter::New();
+//		pdw->SetInput( polyObject);
+//		pdw->SetFileName("/Users/jrelan/Desktop/check.vtk");
+//		
+//		pdw->Update();
+//		pdw->Delete();
+	
+}
+
+
+
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/XMLToVTKObject.h b/src-plugins/libs/vtkInria/vtkDataManagement/XMLToVTKObject.h
new file mode 100644
index 0000000..a9e599a
--- /dev/null
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/XMLToVTKObject.h
@@ -0,0 +1,70 @@
+#ifndef XMLTOVTKOBJECT_H
+#define XMLTOVTKOBJECT_H
+
+#include <string>
+#include <vector>
+#include <vtkAppendPolyData.h>
+#include "CPPXMLReader.h"
+
+
+// using the namespace std for the string type, vector
+using namespace std;
+
+class XMLToVTKObject {
+
+public:
+	
+//enum POLYDATA_ELEMENTS {
+//	Vertices,
+//	Polygons,
+//	Normals
+//}
+//
+//enum MAPPING_ELEMENTS {
+//	Map_Data,
+//	Map_Color,
+//	Color_high_low,
+//	Map_status
+//}
+//
+//enum LABEL_POINTS {
+//	Label
+//}
+//
+//enum GEOMETRY_ALIGNMENT {
+//	AP_MapViewMatrix,
+//	Rotation,
+//	Translation,
+//	Scaling
+//}
+	
+private :
+
+    xmlObject* _xmlObj;
+	bool _isDIFFType;
+	vtkAppendPolyData* _vtkPolygonalVolumes;
+	
+	void CreateFromDIF_XML(xmlObject* _parentObj);
+	void CreateVolumes(xmlObject* _parentObj, vtkAppendPolyData* polyObjects);
+	void CreateVolume(xmlObject* _parentObj, vtkPolyData* polyObject);
+	void CreateLabel(xmlObject* _parentObj, vtkAppendPolyData* polyObject);
+	
+public:
+	XMLToVTKObject();
+	XMLToVTKObject(xmlObject* _obj);
+	~XMLToVTKObject();
+	
+	void setXMLObject(xmlObject* _obj) {_xmlObj=_obj;};
+	xmlObject* getXMLObject(void) {return _xmlObj;};
+		
+	void Update();
+	
+	vtkPolyData* GetPolyData (void) const
+	{
+		return _vtkPolygonalVolumes->GetOutput();
+	}
+};
+
+
+
+#endif // XMLTOVTKOBJECT_H
\ No newline at end of file
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkCardioInsightDataReader.cxx b/src-plugins/libs/vtkInria/vtkDataManagement/vtkCardioInsightDataReader.cxx
new file mode 100644
index 0000000..3ab217c
--- /dev/null
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/vtkCardioInsightDataReader.cxx
@@ -0,0 +1,174 @@
+/*=========================================================================
+
+ medInria
+
+ Copyright (c) INRIA 2013. All rights reserved.
+ See LICENSE.txt for details.
+
+  This software is distributed WITHOUT ANY WARRANTY; without even
+  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+  PURPOSE.
+
+=========================================================================*/
+
+#include "vtkCardioInsightDataReader.h"
+
+#include <vtksys/SystemTools.hxx>
+#include <vtksys/ios/sstream>
+#include <vtkstd/string>
+#include <vtkstd/vector>
+#include "vtkSmartPointer.h"
+#include <string>
+#include "vtkDataManager.h"
+#include "vtkMetaDataSetSequence.h"
+#include "vtkDataSet.h"
+#include "vtkObjectFactory.h"
+#include "vtkMetaSurfaceMesh.h"
+#include <vtkPolyData.h>
+#include <vtkDataArrayCollection.h>
+#include <vtkCellArray.h>
+#include <vtkActor.h>
+#include <vtkProperty.h>
+#include <vtkTransformFilter.h>
+#include <vtkTransformPolyDataFilter.h>
+#include <vtkTransform.h>
+#include <vtkLinearTransform.h>
+#include <vtkMatrix4x4.h>
+#include <vtkPolyDataWriter.h>
+
+#include <string.h>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+
+using namespace std;
+
+//----------------------------------------------------------------------------
+vtkStandardNewMacro(vtkCardioInsightDataReader);
+vtkCxxRevisionMacro(vtkCardioInsightDataReader, "$Revision: 1298 $");
+
+//----------------------------------------------------------------------------
+vtkCardioInsightDataReader::vtkCardioInsightDataReader()
+{
+
+    this->FileName = "";
+    this->Output=NULL;
+
+}
+
+//----------------------------------------------------------------------------
+vtkCardioInsightDataReader::~vtkCardioInsightDataReader()
+{
+}
+
+
+//----------------------------------------------------------------------------
+void vtkCardioInsightDataReader::PrintSelf(ostream& os, vtkIndent indent)
+{
+    //	if(mainXmlObj)
+    //		this->printXMLDetails(os,mainXmlObj);
+    //	else
+    //		vtkErrorMacro(<<"No XML object present"<<endl);
+}
+
+
+//----------------------------------------------------------------------------
+vtkDataSet* vtkCardioInsightDataReader::buildVTKPolyDataset()
+{
+    ifstream datafile((this->FileName).c_str());
+    std::string line;
+
+    vtkPolyData* polyObject=vtkPolyData::New();
+
+    if (datafile.is_open())
+    {
+        getline(datafile,line);
+
+        int NumberOfVertices=atoi(line.c_str());
+        vtkPoints *points=vtkPoints::New();
+        points->SetNumberOfPoints (NumberOfVertices);
+
+        getline(datafile,line);
+
+        int NumberOfPolygons=atoi(line.c_str());
+        polyObject->Allocate (NumberOfPolygons);
+
+        int VertexNum=0;
+        float vTuple[3];
+
+        while (VertexNum<NumberOfVertices)
+        {
+            getline(datafile,line);
+
+            istringstream iss(line);
+            iss >> vTuple[0];
+            iss >> vTuple[1];
+            iss >> vTuple[2];
+
+            points->SetPoint (VertexNum, vTuple[0], vTuple[1], vTuple[2]);
+            // trick to scale the cardioInsight meshes, which are small due to computational costs
+            //points->SetPoint (VertexNum, 10*vTuple[0], 10*vTuple[1], 10*vTuple[2]);
+
+            VertexNum++;
+        }
+        polyObject->SetPoints(points);
+        points->Delete();
+
+
+        int PolyNum=0;
+
+        while (PolyNum<NumberOfPolygons)
+        {
+            getline(datafile,line);
+
+            istringstream iss(line);
+            unsigned int ids[3];
+            iss >> ids[0];
+            iss >> ids[1];
+            iss >> ids[2];
+
+            vtkIdList* idlist = vtkIdList::New();
+            idlist->InsertNextId (ids[0]-1);
+            idlist->InsertNextId (ids[1]-1);
+            idlist->InsertNextId (ids[2]-1);
+
+            polyObject->InsertNextCell (VTK_TRIANGLE, idlist);
+            idlist->Delete();
+
+            PolyNum++;
+        }
+
+        polyObject->Update();
+        return polyObject;
+    }
+    return NULL;
+}
+
+//----------------------------------------------------------------------------
+void vtkCardioInsightDataReader::Update(void)
+{
+    if(this->FileName=="")
+    {
+        vtkErrorMacro(<<"Input file was not set properly !"<<endl);
+        return;
+    }
+
+    if(this->Output)
+        this->Output->Delete();
+
+    this->Output=NULL;
+
+    try
+    {
+        this->Output=this->buildVTKPolyDataset();
+    }
+    catch (vtkErrorCode::ErrorIds error)
+    {
+        vtkErrorMacro(<<"Could not build polydata file !"<<endl);
+        this->Output->Delete();
+        this->Output=NULL;
+        return;
+    }
+
+}
+
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkCardioInsightDataReader.h b/src-plugins/libs/vtkInria/vtkDataManagement/vtkCardioInsightDataReader.h
new file mode 100644
index 0000000..e7b7de7
--- /dev/null
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/vtkCardioInsightDataReader.h
@@ -0,0 +1,65 @@
+/*=========================================================================
+
+ medInria
+
+ Copyright (c) INRIA 2013. All rights reserved.
+ See LICENSE.txt for details.
+
+  This software is distributed WITHOUT ANY WARRANTY; without even
+  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+  PURPOSE.
+
+=========================================================================*/
+
+#pragma once
+
+#include "vtkDataManagementExport.h"
+
+#include "vtkObject.h"
+#include "vtkDataSet.h"
+
+#include <string>
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+class vtkDataManager;
+class vtkMetaDataSet;
+
+
+class VTK_DATAMANAGEMENT_EXPORT vtkCardioInsightDataReader : public vtkObject
+{
+public:
+    static vtkCardioInsightDataReader* New();
+    vtkTypeRevisionMacro(vtkCardioInsightDataReader,vtkObject);
+    void PrintSelf(ostream& os, vtkIndent indent);
+
+    // Description:
+    // Set/Get an input of this algorithm. You should not override these
+    // methods because they are not the only way to connect a pipeline
+    vtkDataSet* GetOutputAsDataSet() {return Output;}
+    const char* GetDataSetName() {return NULL;}
+    void SetupEmptyOutput() {}
+
+    // see algorithm for more info
+    virtual void Update (void);
+
+    void SetFileName (const char* file)
+    { this->FileName = file; }
+    char* GetFileName (void)
+    { return ((char*)this->FileName.c_str()); }
+
+
+protected:
+    vtkCardioInsightDataReader();
+    ~vtkCardioInsightDataReader();
+
+    vtkDataSet* buildVTKPolyDataset();
+
+private:
+    vtkCardioInsightDataReader(const vtkCardioInsightDataReader&);  // Not implemented.
+    void operator=(const vtkCardioInsightDataReader&);  // Not implemented.
+
+    vtkDataSet* Output;
+    std::string FileName;
+};
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLReader.cxx b/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLReader.cxx
new file mode 100644
index 0000000..9dbab75
--- /dev/null
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLReader.cxx
@@ -0,0 +1,304 @@
+/*=========================================================================
+
+ medInria
+
+ Copyright (c) INRIA 2013. All rights reserved.
+ See LICENSE.txt for details.
+
+  This software is distributed WITHOUT ANY WARRANTY; without even
+  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+  PURPOSE.
+
+=========================================================================*/
+
+#include "vtkDiffXMLReader.h"
+
+#include <vtksys/SystemTools.hxx>
+#include <vtksys/ios/sstream>
+#include <vtkstd/string>
+#include <vtkstd/vector>
+#include "vtkSmartPointer.h"
+#include <string>
+#include "vtkDataManager.h"
+#include "vtkMetaDataSetSequence.h"
+#include "vtkDataSet.h"
+#include "vtkObjectFactory.h"
+#include "vtkMetaSurfaceMesh.h"
+#include <vtkPolyData.h>
+#include <vtkDataArrayCollection.h>
+#include <vtkCellArray.h>
+#include <vtkActor.h>
+#include <vtkProperty.h>
+#include <vtkTransformFilter.h>
+#include <vtkTransformPolyDataFilter.h>
+#include <vtkTransform.h>
+#include <vtkLinearTransform.h>
+#include <vtkMatrix4x4.h>
+#include <vtkPolyDataWriter.h>
+
+#include "CPPXMLReader.h"
+#include "XMLToVTKObject.h"
+
+//----------------------------------------------------------------------------
+vtkStandardNewMacro(vtkDiffXMLReader);
+vtkCxxRevisionMacro(vtkDiffXMLReader, "$Revision: 1298 $");
+
+//----------------------------------------------------------------------------
+vtkDiffXMLReader::vtkDiffXMLReader()
+{    
+    this->FileName = "";
+    this->mainXmlObj=NULL;
+    this->Output=NULL;
+}
+
+//----------------------------------------------------------------------------
+vtkDiffXMLReader::~vtkDiffXMLReader()
+{
+}
+
+
+//----------------------------------------------------------------------------
+void vtkDiffXMLReader::PrintSelf(ostream& os, vtkIndent indent)
+{
+    if(mainXmlObj)
+        this->printXMLDetails(os,mainXmlObj);
+    else
+        vtkErrorMacro(<<"No XML object present"<<endl);
+}
+
+
+//----------------------------------------------------------------------------
+void vtkDiffXMLReader::readDiffFile()
+{
+    string line, Text, tagName, wholeFile;
+    xmlObject* xmlObj=NULL;
+
+    ifstream saveFileAsString((this->FileName).c_str());
+    if (saveFileAsString.is_open())
+    {
+        std::stringstream buffer;
+        buffer << saveFileAsString.rdbuf();
+        wholeFile = buffer.str();
+    }
+    saveFileAsString.close();
+
+    this->XmlFile.open((this->FileName).c_str());
+
+    if ((this->XmlFile).is_open())
+    {
+        // if the xml version and also the encodingvalues are present.
+        getline((this->XmlFile),line);
+        xmlObj = xmlReader::readLine(line,&tagName);
+
+        if (xmlObj)
+            if (!xmlObj->getXmlMainDetails())
+            {
+                vtkErrorMacro(<<"unknown XML dataset type : "<<(this->FileName).c_str()<<endl);
+                throw vtkErrorCode::UnrecognizedFileTypeError;
+                return;
+            }
+        if(!xmlObj)
+        {
+            vtkErrorMacro(<<"unknown XML dataset type : "<<(this->FileName).c_str()<<endl);
+            throw vtkErrorCode::UnrecognizedFileTypeError;
+            return;
+        }
+
+
+        // if the file is diff file
+        getline((this->XmlFile),line);
+        mainXmlObj = NULL;
+
+        mainXmlObj = xmlReader::readLine(line,&tagName);
+
+        if(mainXmlObj)
+        {
+            if (mainXmlObj->getTagName() != "DIF")
+            {
+                vtkErrorMacro(<<"Not a standard DIF filetype : "<<(this->FileName).c_str()<<endl);
+                throw vtkErrorCode::UnrecognizedFileTypeError;
+                return;
+            }
+        }
+
+        if(!mainXmlObj)
+        {
+            vtkErrorMacro(<<"Not a standard DIF filetype : "<<(this->FileName).c_str()<<endl);
+            throw vtkErrorCode::UnrecognizedFileTypeError;
+            return;
+        }
+
+        size_t last_position;
+        Text = xmlReader::getTextInBetween(wholeFile,mainXmlObj->getRawTagName(),&last_position);
+
+        this->readInternal(mainXmlObj,Text);
+    }
+
+}
+
+//----------------------------------------------------------------------------
+int vtkDiffXMLReader::readInternal(xmlObject* Parent_obj, string text_in_between)
+{
+    xmlObject* xmlObj=NULL;
+    string Text, tagName;
+
+    Text = text_in_between;
+
+    int position=0;
+    int skip_positions=0;
+    istringstream iss(text_in_between);
+
+    bool doit=true;
+    size_t start_found, stop_found, endTag_found;
+    string subLineUsed="";
+
+    string subLine;
+    iss >> subLine;
+    position++;
+
+    while(iss)
+    {
+        start_found=subLine.find("<");
+        stop_found=subLine.find(">");
+
+        if (start_found!=string::npos)
+            doit=false;
+        if (stop_found!=string::npos)
+        {
+            doit=true;
+            if (stop_found!=(subLine.length())-1)
+            {
+                endTag_found=subLine.find("</",stop_found+1);
+                if (endTag_found==string::npos)
+                {
+                    if(subLine.find("-->")!=string::npos)
+                        subLine=subLine.substr(stop_found+1,string::npos);
+                    else
+                        subLine=subLine.substr(0,stop_found+1);
+                }
+            }
+        }
+
+
+        if(subLineUsed!="")
+            subLineUsed = subLineUsed + " " + subLine;
+        else
+            subLineUsed = subLineUsed + subLine;
+
+        if((subLine.find("<!--")!=string::npos)||(subLine.find("-->")!=string::npos))
+        {
+            doit=false;
+            subLineUsed="";
+        }
+
+
+        if(doit)
+        {
+            //				std::cout<<"examining nowwwww :"<<subLineUsed<<"\ncalled from : "<<Parent_obj->getTagName()<<"\n\n\n"<<std::endl;
+            string endTagName = "</"+Parent_obj->getTagName()+">";
+            if(subLineUsed==endTagName || subLineUsed=="")
+                break;
+
+            xmlObj = xmlReader::readLine(subLineUsed,&tagName);
+
+            if(xmlObj)
+            {
+                if(xmlObj->getTagName() != "")
+                {
+                    Parent_obj->setChild(xmlObj);
+
+                    if(!(xmlObj->isCompleted()))
+                    {
+                        size_t last_position;
+
+                        Text=xmlReader::getTextInBetween(text_in_between,xmlObj->getRawTagName(),&last_position,Parent_obj->getLastPosition());
+
+                        if((Text.find("<")==string::npos) && (Text.find(">")==string::npos))
+                            xmlObj->setTagValuesFromText(Text);
+                        else
+                            skip_positions = this->readInternal(xmlObj,Text);
+
+                        xmlObj->setCompleted(true);
+
+                        iss.seekg(last_position);
+                        Parent_obj->setLastPosition(last_position);
+
+                        position+=(skip_positions);
+                    }
+                    else
+                    {
+                        iss >> subLine;
+                        position++;
+                        break;
+                    }
+                }
+
+            }
+
+            subLineUsed = "";
+        }
+
+        iss >> subLine;
+        position++;
+
+    }
+    return position;
+}
+
+//----------------------------------------------------------------------------
+void vtkDiffXMLReader::printXMLDetails(ostream& os, xmlObject* Parent_obj)
+{
+
+    for(int cc=0;cc<(Parent_obj->getChildren()).size();cc++)
+    {
+        os<<Parent_obj->getTagName()<<"-->"<<((Parent_obj->getChildren())[cc])->getTagName()<<"\t";
+        ((Parent_obj->getChildren())[cc])->printOutXmlObject(os);
+        this->printXMLDetails(os,(Parent_obj->getChildren())[cc]);
+    }
+    os<<"\n\n\n";
+}
+
+
+
+
+
+//----------------------------------------------------------------------------
+void vtkDiffXMLReader::Update(void)
+{
+    std::cout<<"reading DIFF XML type"<<std::endl;
+
+    this->readDiffFile();
+
+    std::cout<<mainXmlObj->getTagName()<<"\t";
+    this->printXMLDetails(std::cout,mainXmlObj);
+
+    XMLToVTKObject* polyObj = new XMLToVTKObject(mainXmlObj);
+    try
+    {
+        polyObj->Update();
+    }
+    catch (vtkErrorCode::ErrorIds error)
+    {
+        delete polyObj;
+        return;
+    }
+
+    //	this->Output = vtkPolyData::New();
+    //	this->Output->DeepCopy(polyObj->GetPolyData());
+    //	this->Output->Update();
+
+    this->Output= polyObj->GetPolyData();
+
+    //	polyObj->GetPolyData()->Print(std::cout);
+    //	this->Output->Print(std::cout);
+
+
+    //	vtkPolyDataWriter* pdw = vtkPolyDataWriter::New();
+    //	pdw->SetInput( this->Output);
+    //	pdw->SetFileName("/Users/jrelan/Desktop/check3.vtk");
+    //
+    //	pdw->Update();
+    //	pdw->Delete();
+
+}
+
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLReader.h b/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLReader.h
new file mode 100644
index 0000000..43ac7ad
--- /dev/null
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLReader.h
@@ -0,0 +1,74 @@
+/*=========================================================================
+
+ medInria
+
+ Copyright (c) INRIA 2013. All rights reserved.
+ See LICENSE.txt for details.
+
+  This software is distributed WITHOUT ANY WARRANTY; without even
+  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+  PURPOSE.
+
+=========================================================================*/
+
+#pragma once
+
+#include "vtkDataManagementExport.h"
+
+#include "vtkObject.h"
+#include "vtkXMLReader.h"
+#include "CPPXMLReader.h"
+
+#include <string>
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+class vtkDataManager;
+class vtkMetaDataSet;
+class vtkDiffXMLReaderInternals;
+
+
+class VTK_DATAMANAGEMENT_EXPORT vtkDiffXMLReader : public vtkXMLReader
+{
+public:
+    static vtkDiffXMLReader* New();
+    vtkTypeRevisionMacro(vtkDiffXMLReader,vtkObject);
+    void PrintSelf(ostream& os, vtkIndent indent);
+
+    // Description:
+    // Set/Get an input of this algorithm. You should not override these
+    // methods because they are not the only way to connect a pipeline
+    vtkDataSet* GetOutputAsDataSet(){return Output;}
+    const char* GetDataSetName(){return NULL;}
+    void SetupEmptyOutput(){}
+
+    // see algorithm for more info
+    virtual void Update (void);
+
+    void SetFileName (const char* file)
+    { this->FileName = file; }
+    char* GetFileName (void)
+    { return ((char*)this->FileName.c_str()); }
+
+    void printXMLDetails(ostream& os,xmlObject* Parent_obj);
+
+protected:
+    vtkDiffXMLReader();
+    ~vtkDiffXMLReader();
+
+    void readDiffFile();
+
+
+private:
+    vtkDiffXMLReader(const vtkDiffXMLReader&);  // Not implemented.
+    void operator=(const vtkDiffXMLReader&);  // Not implemented.
+
+    int readInternal(xmlObject* Parent_obj, string text_in_between);
+
+    vtkDataSet* Output;
+
+    std::string FileName;
+    xmlObject* mainXmlObj;
+    std::ifstream XmlFile;
+};
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLWriter.cxx b/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLWriter.cxx
deleted file mode 100644
index 54ea3fb..0000000
--- a/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLWriter.cxx
+++ /dev/null
@@ -1,160 +0,0 @@
-/*=========================================================================
-
- medInria
-
- Copyright (c) INRIA 2013. All rights reserved.
- See LICENSE.txt for details.
- 
-  This software is distributed WITHOUT ANY WARRANTY; without even
-  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-  PURPOSE.
-
-=========================================================================*/
-
-#include "vtkDiffXMLWriter.h"
-
-#include <string>
-#include <vector>
-#include <vtksys/SystemTools.hxx>
-#include <vtksys/ios/sstream>
-#include "vtkSmartPointer.h"
-#include "vtkDataManager.h"
-#include "vtkMetaDataSetSequence.h"
-#include "vtkDataSet.h"
-#include "vtkObjectFactory.h"
-#include "vtkMetaSurfaceMesh.h"
-#include <vtkPolyData.h>
-#include <vtkDataArrayCollection.h>
-#include <vtkCellArray.h>
-#include <vtkActor.h>
-#include <vtkProperty.h>
-//----------------------------------------------------------------------------
-vtkStandardNewMacro(vtkDiffXMLWriter);
-vtkCxxRevisionMacro(vtkDiffXMLWriter, "$Revision: 1298 $");
-
-//----------------------------------------------------------------------------
-vtkDiffXMLWriter::vtkDiffXMLWriter()
-{
-
-  this->Input = 0;
-  this->FileName = "";
-}
-
-//----------------------------------------------------------------------------
-vtkDiffXMLWriter::~vtkDiffXMLWriter()
-{
-}
-
-
-//----------------------------------------------------------------------------
-void vtkDiffXMLWriter::PrintSelf(ostream& os, vtkIndent indent)
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkDiffXMLWriter::SetInput (vtkDataManager* manager)
-{
-  this->Input = manager;
-}
-
-//----------------------------------------------------------------------------
-vtkDataManager* vtkDiffXMLWriter::GetInput()
-{
-  return this->Input;
-}
-
-
-//----------------------------------------------------------------------------
-void vtkDiffXMLWriter::Update()
-{
-  std::cout<<"writing DIFF XML type"<<std::endl;
-  
-  std::ostringstream os;
-  
-  std::vector<vtkMetaDataSet*> datasetlist = this->Input->GetMetaDataSetList();
-  
-  os<<"<?xml version=\"1.0\"?>"<<std::endl;
-  os<<"<DIF>"<<std::endl;
-  os<<"\t<DIFBody>"<<std::endl;
-  os<<"\t\t<Volumes number=\""<<datasetlist.size()<<"\">"<<std::endl;
-  
-  vtkMetaSurfaceMesh* metasurface = 0;
-  vtkDataArrayCollection* arrays = vtkDataArrayCollection::New();
-  vtkIdList* pointids = vtkIdList::New();
-  double point[3];
-  
-  for (unsigned int j=0; j<datasetlist.size(); j++)
-  {
-    
-    vtkMetaDataSet* metadata = datasetlist[j];
-    std::string filepath = metadata->GetFilePath();
-    int val = metadata->GetType();
-
-    if (val != vtkMetaDataSet::VTK_META_SURFACE_MESH)
-      continue;
-    
-    metasurface = vtkMetaSurfaceMesh::SafeDownCast(metadata);
-    metadata->GetColorArrayCollection (arrays);
-    
-    os<<"\t\t\t<Volume name=\""<<metadata->GetName()<<"\" color=\"";
-    
-    // // TODO: Color required to be in Hexadecimal values, but when asked from vtk object it is returned as RGB values, Thus conversion required here.    
-    // //double *color; color = metadata->GetActor(0)->GetProperty()->GetColor();
-    					
-    // //printf("color %x",color[0]);
-    // double dv;
-    // char *sv;
-    // int i;
-    
-    // dv=0.1;
-    // sv=(char *) &dv;
-    // printf("sv -> ");
-    // for (i=0;i<sizeof (double);++i)
-    //   printf("%x ",sv[i]);
-    // printf("\n");
-    
-    os<<"\">"<<std::endl;
-
-    os <<"\t\t\t\t<Vertices number=\""<<metasurface->GetPolyData()->GetNumberOfPoints()<<"\">"<<std::endl;
-    for(vtkIdType i=0;i<metasurface->GetPolyData()->GetNumberOfPoints();i++)
-    {
-      metasurface->GetPolyData()->GetPoint(i,point);
-      os<<"\t\t\t\t\t"<<point[0]<<" "<<point[1]<<" "<<point[2]<<std::endl;
-    }
-    os<<"\t\t\t\t</Vertices>"<<std::endl;
-    
-    os<<"\t\t\t\t<Polygons number=\""<<metasurface->GetPolyData()->GetPolys()->GetNumberOfCells()<<"\">"<<std::endl;
-    for(int i=0;i<metasurface->GetPolyData()->GetPolys()->GetNumberOfCells();++i)
-    {
-      metasurface->GetPolyData()->GetCellPoints(i, pointids);
-      if (pointids->GetNumberOfIds() != 3)
-      {
-	vtkWarningMacro(<<"warning : wrong type of cells !"<<endl);
-	pointids->Delete();
-	return;
-      }
-      os<<"\t\t\t\t\t"<<(pointids->GetId(0)+1)<<" "<<(pointids->GetId(1)+1)<<" "<<(pointids->GetId(2)+1)<<std::endl;
-    }
-    os<<"\t\t\t\t</Polygons>"<<std::endl;
-    os<<"\t\t\t</Volume>"<<std::endl;
-  }
-
-  pointids->Delete();
-  arrays->Delete();
-  
-  os<<"\t\t</Volumes>"<<std::endl;
-  os<<"\t<DIFBody>"<<std::endl;
-  os <<"<DIF>"<<std::endl;
-  
-  // open the file:
-  std::ofstream buffer (this->FileName.c_str());
-  if( buffer.fail() )
-  {
-    vtkErrorMacro(<<"Cannot write in file !"<<endl);
-    buffer.close();
-  }
-  
-  buffer << os.str().c_str() <<std::endl;
-  buffer.close();
-}
-
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLWriter.h b/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLWriter.h
deleted file mode 100644
index c70bc69..0000000
--- a/src-plugins/libs/vtkInria/vtkDataManagement/vtkDiffXMLWriter.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*=========================================================================
-
- medInria
-
- Copyright (c) INRIA 2013. All rights reserved.
- See LICENSE.txt for details.
- 
-  This software is distributed WITHOUT ANY WARRANTY; without even
-  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-  PURPOSE.
-
-=========================================================================*/
-
-#pragma once
-
-#include "vtkObject.h"
-
-#include <string>
-
-class vtkDataManager;
-class vtkMetaDataSet;
-class vtkDiffXMLWriterInternals;
-
-
-class vtkDiffXMLWriter : public vtkObject
-{
-public:
-  static vtkDiffXMLWriter* New();
-  vtkTypeRevisionMacro(vtkDiffXMLWriter,vtkObject);
-  void PrintSelf(ostream& os, vtkIndent indent);  
-
-  // Description:
-  // Set/Get an input of this algorithm. You should not override these
-  // methods because they are not the only way to connect a pipeline
-  void SetInput(vtkDataManager *);
-  vtkDataManager *GetInput();
-
-  // see algorithm for more info
-  virtual void Update();
-  
-  void SetFileName (const char* file)
-  { this->FileName = file; }
-  const char* GetFileName()
-  { return this->FileName.c_str(); }
-	
-  
-protected:
-  vtkDiffXMLWriter();
-  ~vtkDiffXMLWriter();
-  
-private:
-  vtkDiffXMLWriter(const vtkDiffXMLWriter&);  // Not implemented.
-  void operator=(const vtkDiffXMLWriter&);  // Not implemented.
-
-  vtkDataManager* Input;
-  //BTX
-  std::string FileName;
-  //ETX
-};
-
-
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaDataSet.cxx b/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaDataSet.cxx
index a490bf3..de10b18 100644
--- a/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaDataSet.cxx
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaDataSet.cxx
@@ -32,6 +32,9 @@
 #include <vtkLookupTable.h>
 #include <vtkDataArrayCollection.h>
 #include <vtkCell.h>
+#include <vtkLookupTable.h>
+#include <vtkTable.h>
+#include <vtkDelimitedTextReader.h>
 
 #include <vtkPolyData.h>
 
@@ -56,6 +59,7 @@ vtkMetaDataSet::vtkMetaDataSet()
   this->PickedCellId     = -1;
   this->Name             = "";
   this->FilePath         = "";
+  this->LookupTable = NULL;
   this->Initialize();
   
 }
@@ -145,6 +149,13 @@ void vtkMetaDataSet::SetDataSet (vtkDataSet* dataset)
   this->Modified();
 }
 
+//----------------------------------------------------------------------------
+void vtkMetaDataSet::SetLookupTable (vtkLookupTable* array)
+{
+	vtkLookupTable* lut_array = array->NewInstance();
+	lut_array->DeepCopy (array);
+	this->LookupTable = lut_array;
+}
 
 //----------------------------------------------------------------------------
 void vtkMetaDataSet::SetWirePolyData (vtkPolyData* dataset)
@@ -518,6 +529,84 @@ void vtkMetaDataSet::ReadDataInternal(const char* filename)
   array->Delete();
 }
 
+
+void vtkMetaDataSet::ReadCSVData(const char* filename)
+{
+	vtkDelimitedTextReader* csvReader=vtkDelimitedTextReader::New();
+
+	try
+	{
+		csvReader->SetFileName(filename);
+		csvReader->SetHaveHeaders(false);
+		csvReader->Update();
+	}
+	catch (vtkErrorCode::ErrorIds error)
+	{
+		vtkErrorMacro(<<"Could not read csv file properly !"<<endl);
+		csvReader->Delete();
+		return;
+	}
+	int numberOfLines=csvReader->GetOutput()->GetNumberOfRows();
+	
+	bool PointAttribute=false,CellAttribute=false;
+	if(numberOfLines==this->GetDataSet()->GetNumberOfPoints())
+		PointAttribute=true;
+	else if(numberOfLines==this->GetDataSet()->GetNumberOfCells())
+		CellAttribute=true;
+	else
+	{
+		vtkErrorMacro("number of lines dont match either point data or cell data");
+		throw vtkErrorCode::UserError;
+		return;
+	}
+	
+	std::string Fieldnames="Field_";
+	std::stringstream ss;
+	if(PointAttribute)
+	{
+		for(int i=0;i<csvReader->GetOutput()->GetNumberOfColumns();i++)
+		{
+			vtkFloatArray* array = vtkFloatArray::New();
+			ss << i;
+			array->SetName ((Fieldnames+ss.str()).c_str());
+			array->Allocate(numberOfLines);
+			array->SetNumberOfComponents(1);
+			
+			float* tuple = new float[1];
+			for (unsigned int t=0; t<numberOfLines; t++)
+			{
+				tuple[0]=(csvReader->GetOutput()->GetValue(t,i)).ToFloat();
+				array->InsertNextTupleValue (tuple);
+			}
+			delete tuple;
+			this->GetDataSet()->GetPointData()->AddArray (array);
+		}
+	}
+
+	if(CellAttribute)
+	{
+		for(int i=0;i<csvReader->GetOutput()->GetNumberOfColumns();i++)
+		{
+			vtkFloatArray* array = vtkFloatArray::New();
+			ss << i;
+			array->SetName ((Fieldnames+ss.str()).c_str());
+			array->Allocate(numberOfLines);
+			array->SetNumberOfComponents(1);
+			
+			float* tuple = new float[1];
+			for (unsigned int t=0; t<numberOfLines; t++)
+			{
+				tuple[0]=(csvReader->GetOutput()->GetValue(t,i)).ToFloat();
+				array->InsertNextTupleValue (tuple);
+			}
+			delete tuple;
+			this->GetDataSet()->GetCellData()->AddArray (array);
+		}
+	}
+	
+	csvReader->Delete();
+}
+
 //----------------------------------------------------------------------------
 void vtkMetaDataSet::Read (const char* filename)
 {
@@ -562,6 +651,36 @@ void vtkMetaDataSet::CopyInformation (vtkMetaDataSet* metadataset)
   
 }
 
+//----------------------------------------------------------------------------
+double vtkMetaDataSet::GetScalarNullValue(const char * arrayName)
+{
+  if ( ! this->GetDataSet())
+    return NAN;
+
+  vtkDataArray * array = this->GetDataSet()->GetPointData()->GetArray(arrayName);
+  if ( ! array)
+    array = this->GetDataSet()->GetCellData()->GetArray(arrayName);
+  if ( ! array || ScalarNullValues.find(arrayName) == ScalarNullValues.end())
+    return NAN;
+
+  return ScalarNullValues[arrayName];
+}
+
+
+//----------------------------------------------------------------------------
+void vtkMetaDataSet::SetScalarNullValue(const char * arrayName, double nullValue)
+{
+  if ( ! this->GetDataSet())
+    return;
+
+  vtkDataArray * array = this->GetDataSet()->GetPointData()->GetArray(arrayName);
+  if ( ! array)
+    array = this->GetDataSet()->GetCellData()->GetArray(arrayName);
+  if ( ! array)
+    return;
+
+  ScalarNullValues[arrayName] = nullValue;
+}
 
 //----------------------------------------------------------------------------
 double* vtkMetaDataSet::GetCurrentScalarRange()
@@ -572,14 +691,34 @@ double* vtkMetaDataSet::GetCurrentScalarRange()
   
   if (this->GetCurrentScalarArray())
   {
-    double* range2 = this->GetCurrentScalarArray()->GetRange ();
-    val[0] = range2[0];
-    val[1] = range2[1];
+    double nullValue = this->GetScalarNullValue(this->GetCurrentScalarArray()->GetName());
+    if (isnan(nullValue))
+    {
+      double* range2 = this->GetCurrentScalarArray()->GetRange();
+      val[0] = range2[0];
+      val[1] = range2[1];
+    }
+    else
+    {
+      vtkDataArray * array = this->GetCurrentScalarArray();
+      unsigned int nbTuples = array->GetNumberOfTuples();
+      for(unsigned int i = 0; i < nbTuples; ++i)
+      {
+        double t = array->GetTuple1(i);
+        if(fabs(t - nullValue) <= 1e-10) // t == nullValue with a margin of error
+          continue;
+        if (t < val[0]) val[0] = t;
+        if (t > val[1]) val[1] = t;
+      }
+    }
   }
 
-  else if (this->GetDataSet() && ( val[0] == VTK_DOUBLE_MAX ) )
-    val = this->GetDataSet()->GetScalarRange();
-    
+  // if all values are null values, or if we don't have a current scalar array
+  if ( val[0] == VTK_DOUBLE_MAX || val[1] == VTK_DOUBLE_MIN )
+  {
+    val[0] = 0;
+    val[1] = 1;
+  }
 
   return val;
 }
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaDataSet.h b/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaDataSet.h
index 85f7e1d..b9fcd66 100644
--- a/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaDataSet.h
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaDataSet.h
@@ -17,6 +17,12 @@
 #include <string>
 #include <vector>
 
+#if defined __APPLE__
+#include <ext/hash_map>
+#else
+#include <hash_map>
+#endif
+
 #include <vtkDataSet.h>
 
 //#include <vtkActor.h>
@@ -40,6 +46,7 @@ class vtkActor;
 class vtkActorCollection;
 class vtkScalarsToColors;
 class vtkPolyData;
+class vtkLookupTable;
 
 
 class vtkMetaDataSet: public vtkDataObject
@@ -146,6 +153,18 @@ class vtkMetaDataSet: public vtkDataObject
   vtkGetObjectMacro(Property, vtkObject);
   vtkSetObjectMacro(Property, vtkObject);
 
+	
+	/**
+     Access to the visualization property of the metadataset
+     downcast the object to the write type :
+     Lookuptable specified in the vtkfile for vtkMetaSurfaceMesh
+	 */ 
+	void SetLookupTable (vtkLookupTable* array);
+	vtkLookupTable* GetLookupTable (void)
+	{
+		return this->LookupTable;
+	}
+	
   /**
      Add an actor to the metadataset. Use this method
      to be able to handle several actors of the same metadataset at the same time :
@@ -230,6 +249,8 @@ class vtkMetaDataSet: public vtkDataObject
      nb dim (integers. nb is the number of Tuples of the field; dim is the Tuple size)\n\n
   */
   virtual void ReadData (const char* filename);
+  virtual void ReadCSVData(const char* filename); // specific for CSV files
+
   /**
      read and assign some scalars to the dataset (should be point set). 
      Either vtkMetaSurfaceMesh or vtkMetaVolumeMesh. The scalars are casted in float type
@@ -332,6 +353,10 @@ class vtkMetaDataSet: public vtkDataObject
     this->CurrentScalarArray = array;
   }
 
+  virtual double GetScalarNullValue(const char * arrayName);
+
+  virtual void SetScalarNullValue(const char * arrayName, double nullValue);
+
   virtual double* GetCurrentScalarRange();
   
   
@@ -385,6 +410,7 @@ class vtkMetaDataSet: public vtkDataObject
   double      Time;
   vtkObject*  Property;
   vtkDataArrayCollection* ArrayCollection;
+  vtkLookupTable*  LookupTable;
 
   vtkDataArray* CurrentScalarArray;
   
@@ -406,6 +432,7 @@ class vtkMetaDataSet: public vtkDataObject
   //ETX
 
   vtkPolyData* WirePolyData;
+  std::map<const char *, double> ScalarNullValues;
   
   
  
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaSurfaceMesh.cxx b/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaSurfaceMesh.cxx
index 121ba91..5b6aa47 100644
--- a/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaSurfaceMesh.cxx
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaSurfaceMesh.cxx
@@ -27,6 +27,9 @@
 #include <vtkXMLPolyDataReader.h>
 #include <vtkXMLPolyDataWriter.h>
 
+#include <vtkDiffXMLReader.h>
+#include <vtkCardioInsightDataReader.h>
+
 #include <vtkPoints.h>
 #include <vtkIdList.h>
 #include <vtkUnsignedShortArray.h>
@@ -42,8 +45,10 @@
 #include <vtksys/SystemTools.hxx>
 
 #include <vtkCellType.h>
+#include <vtkDoubleArray.h>
 
 #include <vtkLookupTable.h>
+#include <vtkLookupTableManager.h>
 
 #include <vtkErrorCode.h>
 
@@ -97,6 +102,11 @@ void vtkMetaSurfaceMesh::ReadVtkFile (const char* filename)
   {
     reader->Update();
     this->SetDataSet (reader->GetOutput());
+
+	  if(reader->GetOutput()->GetPointData()->GetScalars())
+		  if(reader->GetOutput()->GetPointData()->GetScalars()->GetLookupTable())
+			  this->SetLookupTable(reader->GetOutput()->GetPointData()->GetScalars()->GetLookupTable());
+	  
   }
   catch (vtkErrorCode::ErrorIds error)
   {
@@ -106,6 +116,31 @@ void vtkMetaSurfaceMesh::ReadVtkFile (const char* filename)
   reader->Delete();
 }
 
+
+
+//----------------------------------------------------------------------------
+void vtkMetaSurfaceMesh::ReadDIF_XMLFile (const char* filename)
+{
+	vtkDiffXMLReader* reader = vtkDiffXMLReader::New();
+	reader->SetFileName (filename);
+	
+	try
+	{ 
+		reader->Update();
+		this->SetDataSet (reader->GetOutputAsDataSet());
+		
+//		if(reader->GetLabelsDataSet())
+//			this->SetLabelsDataset(reader->GetLabelsDataSet());
+	}
+	catch (vtkErrorCode::ErrorIds error)
+	{
+		reader->Delete();
+		throw error;
+	}
+	reader->Delete();
+}
+
+
 void vtkMetaSurfaceMesh::ReadVtpFile(const char* filename)
 {
     vtkXMLPolyDataReader* reader = vtkXMLPolyDataReader::New();
@@ -124,6 +159,27 @@ void vtkMetaSurfaceMesh::ReadVtpFile(const char* filename)
     reader->Delete();
 }
 
+
+//----------------------------------------------------------------------------
+void vtkMetaSurfaceMesh::Read_CARDIO_INSIGHT_File (const char* filename)
+{
+	vtkCardioInsightDataReader* reader = vtkCardioInsightDataReader::New();
+	reader->SetFileName (filename);
+	
+	try
+	{ 
+		reader->Update();
+		this->SetDataSet (reader->GetOutputAsDataSet());
+	}
+	catch (vtkErrorCode::ErrorIds error)
+	{
+		reader->Delete();
+		throw error;
+	}
+	reader->Delete();
+}
+
+
 //----------------------------------------------------------------------------
 void vtkMetaSurfaceMesh::ReadOBJFile (const char* filename)
 {
@@ -173,6 +229,12 @@ void vtkMetaSurfaceMesh::Read (const char* filename)
     case vtkMetaSurfaceMesh::FILE_IS_VTP :
       this->ReadVtpFile (filename);
       break;
+	case vtkMetaSurfaceMesh::FILE_IS_DIF :
+	  this->ReadDIF_XMLFile (filename);
+	  break;
+	case vtkMetaSurfaceMesh::FILE_IS_CARDIO_INSIGHT :
+	  this->Read_CARDIO_INSIGHT_File (filename);
+	  break;
 	case vtkMetaSurfaceMesh::FILE_IS_MESH :
 	  this->ReadMeshFile (filename);
 	  break;
@@ -263,6 +325,7 @@ void vtkMetaSurfaceMesh::WriteVtpFile (const char* filename)
     }
 }
 
+
 //----------------------------------------------------------------------------
 void vtkMetaSurfaceMesh::WriteOBJFile (const char* filename)
 {
@@ -325,6 +388,24 @@ bool vtkMetaSurfaceMesh::IsOBJExtension (const char* ext)
   return false;
 }
 
+//----------------------------------------------------------------------------
+bool vtkMetaSurfaceMesh::IsDIFFXMLExtension (const char* ext)
+{
+	if (strcmp (ext, ".dif") == 0)
+		return true;
+	return false;
+}
+
+//----------------------------------------------------------------------------
+bool vtkMetaSurfaceMesh::IsEcVueExtension (const char* ext)
+{
+	if (strcmp (ext, ".ecvue") == 0)
+		return true;
+	return false;
+}
+
+
+
 
 //----------------------------------------------------------------------------
 unsigned int vtkMetaSurfaceMesh::CanReadFile (const char* filename)
@@ -332,6 +413,14 @@ unsigned int vtkMetaSurfaceMesh::CanReadFile (const char* filename)
 
   if (vtkMetaSurfaceMesh::IsMeshExtension(vtksys::SystemTools::GetFilenameLastExtension(filename).c_str()))
     return vtkMetaSurfaceMesh::FILE_IS_MESH;
+	
+	if (vtkMetaSurfaceMesh::IsDIFFXMLExtension(vtksys::SystemTools::GetFilenameLastExtension(filename).c_str()))
+		return vtkMetaSurfaceMesh::FILE_IS_DIF;
+
+	if (vtkMetaSurfaceMesh::IsEcVueExtension(vtksys::SystemTools::GetFilenameLastExtension(filename).c_str()))
+		return vtkMetaSurfaceMesh::FILE_IS_CARDIO_INSIGHT;
+
+	
 
   if (vtkMetaSurfaceMesh::IsOBJExtension(vtksys::SystemTools::GetFilenameLastExtension(filename).c_str()))
   {
@@ -521,60 +610,6 @@ void vtkMetaSurfaceMesh::ReadMeshFile (const char* filename)
     
 }
 
-// void vtkMetaSurfaceMesh::CreateWirePolyDataOld()
-// {
-//   if (this->GetWirePolyData())
-//     return;
-
-//   vtkPolyData* dataset = vtkPolyData::SafeDownCast (this->GetDataSet());
-  
-//   if (!dataset)
-//     return;
-
-//   vtkCellArray* celldata = vtkCellArray::New();
-//   celldata->Initialize();
-
-//   for(unsigned int i=0;i<dataset->GetPolys()->GetNumberOfCells();++i)
-//   {
-//     vtkIdList* pointids = vtkIdList::New();
-//     dataset->GetCellPoints(i, pointids);
-//     if (pointids->GetNumberOfIds() != 3)
-//     {
-//       std::cout<<"strange triangle"<<std::endl;
-//       continue;
-//     }
-    
-//     vtkLine* line1 = vtkLine::New();
-//     line1->GetPointIds()->SetId (0, pointids->GetId (0));
-//     line1->GetPointIds()->SetId (1, pointids->GetId (2));
-//     celldata->InsertNextCell (line1);
-//     line1->Delete();
-//     vtkLine* line2 = vtkLine::New();
-//     line2->GetPointIds()->SetId (0, pointids->GetId (2));
-//     line2->GetPointIds()->SetId (1, pointids->GetId (1));
-//     celldata->InsertNextCell (line2);
-//     line2->Delete();
-//     vtkLine* line3 = vtkLine::New();
-//     line3->GetPointIds()->SetId (0, pointids->GetId (1));
-//     line3->GetPointIds()->SetId (1, pointids->GetId (0));
-//     celldata->InsertNextCell (line3);
-//     line3->Delete();
-    
-//     pointids->Delete();
-//     i++;
-    
-//   }
-
-// //   dataset->SetLines (celldata);
-//   celldata->Delete();
-
-//   dataset->Modified();
-//   this->Modified();
-  
-  
-// }
-
-
 void vtkMetaSurfaceMesh::CreateWirePolyData()
 {
   if (this->GetWirePolyData())
@@ -591,46 +626,5 @@ void vtkMetaSurfaceMesh::CreateWirePolyData()
 
   extractor->Delete();
   
-
-//   vtkPolyData* dataset = vtkPolyData::New();
-//   dataset->SetPoints (this->GetPolyData()->GetPoints());
-//   dataset->Allocate();
-
-  
-//   for(unsigned int i=0;i<this->GetPolyData()->GetPolys()->GetNumberOfCells();++i)
-//   {
-//     vtkIdList* pointids = vtkIdList::New();
-//     this->GetPolyData()->GetCellPoints(i, pointids);
-//     if (pointids->GetNumberOfIds() != 3)
-//     {
-//       vtkWarningMacro(<<"warning : wrong type of cells !"<<endl);
-//       pointids->Delete();
-//       dataset->Delete();
-      
-//       return;
-//     }
-    
-//     vtkIdList* list = vtkIdList::New();
-//     list->SetNumberOfIds(2);
-    
-//     list->SetId (0, pointids->GetId (0));
-//     list->SetId (1, pointids->GetId (1));
-//     dataset->InsertNextCell (VTK_LINE, list);
-//     list->SetId (0, pointids->GetId (1));
-//     list->SetId (1, pointids->GetId (2));
-//     dataset->InsertNextCell (VTK_LINE, list);
-//     list->SetId (0, pointids->GetId (2));
-//     list->SetId (1, pointids->GetId (0));
-//     dataset->InsertNextCell (VTK_LINE, list);
-
-//     list->Delete();
-//     pointids->Delete();
-//     i++;
-    
-//   }
-
-//   this->SetWirePolyData (dataset);
-//   dataset->Delete();
-  
   this->Modified();
 }
diff --git a/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaSurfaceMesh.h b/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaSurfaceMesh.h
index 550391e..c9cb113 100644
--- a/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaSurfaceMesh.h
+++ b/src-plugins/libs/vtkInria/vtkDataManagement/vtkMetaSurfaceMesh.h
@@ -52,6 +52,8 @@ class VTK_DATAMANAGEMENT_EXPORT vtkMetaSurfaceMesh: public vtkMetaDataSet
     FILE_IS_VTP,
     FILE_IS_MESH,
     FILE_IS_OBJ,
+	FILE_IS_DIF, // for ensite data
+	FILE_IS_CARDIO_INSIGHT, // for cardio-insight data
     LAST_FILE_ID
   };
   //ETX
@@ -75,6 +77,9 @@ class VTK_DATAMANAGEMENT_EXPORT vtkMetaSurfaceMesh: public vtkMetaDataSet
   static bool         IsVtpExtension (const char* ext);
   static bool         IsMeshExtension (const char* ext);
   static bool         IsOBJExtension (const char* ext);
+  static bool         IsDIFFXMLExtension (const char* ext);
+  static bool         IsEcVueExtension (const char* ext);
+	
   static unsigned int CanReadFile (const char* filename);
 
   /**
@@ -93,12 +98,14 @@ class VTK_DATAMANAGEMENT_EXPORT vtkMetaSurfaceMesh: public vtkMetaDataSet
 
   virtual void ReadVtkFile(const char* filename);
   virtual void ReadVtpFile(const char* filename);
+  virtual void ReadDIF_XMLFile (const char* filename);
+  virtual void Read_CARDIO_INSIGHT_File (const char* filename);
   virtual void ReadMeshFile(const char* filename);
   virtual void ReadOBJFile(const char* filename);
   virtual void WriteOBJFile(const char* filename);
-  virtual void WriteVtkFile (const char* filename);
-  virtual void WriteVtpFile (const char* filename);
-
+  virtual void WriteVtkFile(const char* filename);
+  virtual void WriteVtpFile(const char* filename);
+	
   /**
      Method called everytime the dataset changes for initialization
   */
diff --git a/src-plugins/libs/vtkInria/vtkVisuManagement/vtkLookupTableManager.cxx b/src-plugins/libs/vtkInria/vtkVisuManagement/vtkLookupTableManager.cxx
index 9cc3121..b957820 100644
--- a/src-plugins/libs/vtkInria/vtkVisuManagement/vtkLookupTableManager.cxx
+++ b/src-plugins/libs/vtkInria/vtkVisuManagement/vtkLookupTableManager.cxx
@@ -52,6 +52,7 @@ std::vector<std::string> vtkLookupTableManager::GetAvailableLookupTables()
 			  "Black & White",
 			  "Black & White Inversed",
 			  "Spectrum",
+			  "Cardiac Activation",
 			  "Hot Metal",
 			  "Hot Green",
 			  "Hot Iron",
@@ -75,7 +76,8 @@ std::vector<std::string> vtkLookupTableManager::GetAvailableLookupTables()
     
 
   std::vector<std::string> v_lutNames;
-  for( int i=0; i<24; i++)
+  int nbLuts = sizeof(lutNames)/sizeof(lutNames[0]);
+  for( int i=0; i<nbLuts; i++)
   {
     v_lutNames.push_back(lutNames[i]);
   }
@@ -104,6 +106,8 @@ vtkLookupTable* vtkLookupTableManager::GetLookupTable(const std::string & name)
     return vtkLookupTableManager::GetBWInverseLookupTable();
   else if ( name == "Spectrum" )
     return vtkLookupTableManager::GetSpectrumLookupTable();
+  else if ( name == "Cardiac Activation" )
+	  return vtkLookupTableManager::GetCardiacActivationLookupTable();
   else if ( name == "Hot Metal" )
     return vtkLookupTableManager::GetHotMetalLookupTable();
   else if ( name == "Hot Green" )
@@ -192,6 +196,22 @@ vtkLookupTable* vtkLookupTableManager::GetSpectrumLookupTable()
   return lut;
 }
 
+vtkLookupTable* vtkLookupTableManager::GetCardiacActivationLookupTable()
+{
+	vtkLookupTable* lut = vtkLookupTable::New();
+	lut->SetNumberOfTableValues(256);
+	lut->Build();
+	
+	for( int i=0; i<256; i++)
+	{
+		//	lut->SetTableValue(i, (double)Spectrum[i]/255.0, (double)Spectrum[256+i]/255.0, (double)Spectrum[256*2+i]/255.0, (double)(i)/255.0 );
+		lut->SetTableValue(i,(double)Spectrum[256*2+i]/255.0,(double)Spectrum[256+i]/255.0,(double)Spectrum[i]/255.0, 1.0 );
+	}
+	
+	return lut;
+}
+
+
 
 vtkLookupTable* vtkLookupTableManager::GetHotMetalLookupTable()
 {
@@ -313,6 +333,7 @@ vtkLookupTable*  vtkLookupTableManager::GetRedBlackAlphaLookupTable()
   return lut;
 }
 
+
 vtkLookupTable*   vtkLookupTableManager::GetGreenBlackAlphaLookupTable()
 {
   vtkLookupTable* lut = vtkLookupTable::New();
@@ -602,3 +623,17 @@ vtkLookupTable* vtkLookupTableManager::GetJetLookupTable()
   return lut;
 
 }
+
+vtkLookupTable*  vtkLookupTableManager::CreateLookupTable(double r, double g, double b, double alpha)
+{  
+    vtkLookupTable* lut = vtkLookupTable::New();
+	
+	lut->SetNumberOfTableValues(2);
+	lut->SetRange(0.0,1.0);
+	lut->SetTableValue( 0, 0.0, 0.0, 0.0, 0.0 ); //label 0 is transparent
+	lut->SetTableValue( 1, 0.0, 1.0, 0.0, 0.5 ); //label 1 is opaque and green
+	
+	lut->Build();
+	
+	return lut;
+}
diff --git a/src-plugins/libs/vtkInria/vtkVisuManagement/vtkLookupTableManager.h b/src-plugins/libs/vtkInria/vtkVisuManagement/vtkLookupTableManager.h
index 6423575..e9a383a 100644
--- a/src-plugins/libs/vtkInria/vtkVisuManagement/vtkLookupTableManager.h
+++ b/src-plugins/libs/vtkInria/vtkVisuManagement/vtkLookupTableManager.h
@@ -31,6 +31,7 @@ class VTK_VISUMANAGEMENT_EXPORT vtkLookupTableManager: public vtkObject
     LUT_BW = 0,
     LUT_BWINV,
     LUT_SPECTTUM,
+    LUT_CARDIAC_ACTIVATION,
     LUT_HOTMETAL,
     LUT_HOTGREEN,
     LUT_HOTIRON,
@@ -60,6 +61,8 @@ class VTK_VISUMANAGEMENT_EXPORT vtkLookupTableManager: public vtkObject
   static vtkLookupTable* GetBWInverseLookupTable();
 
   static vtkLookupTable* GetSpectrumLookupTable();
+	
+  static vtkLookupTable* GetCardiacActivationLookupTable();
 
   static vtkLookupTable* GetHotMetalLookupTable();
 
@@ -102,6 +105,8 @@ class VTK_VISUMANAGEMENT_EXPORT vtkLookupTableManager: public vtkObject
   static vtkLookupTable* GetBlackBodyLookupTable();
   
   static vtkLookupTable* GetJetLookupTable();
+
+  static vtkLookupTable*  CreateLookupTable(double r, double g, double b, double alpha);
   
   //BTX
   static std::vector<std::string> GetAvailableLookupTables();
diff --git a/src/medSql/medDatabaseExporter.cpp b/src/medSql/medDatabaseExporter.cpp
index f18f2de..4c08818 100644
--- a/src/medSql/medDatabaseExporter.cpp
+++ b/src/medSql/medDatabaseExporter.cpp
@@ -55,8 +55,10 @@ void medDatabaseExporter::run(void)
     dtkAbstractDataWriter * dataWriter = dtkAbstractDataFactory::instance()->writer(d->writer);
     dataWriter->setData(d->data);
 
+    qDebug() << "lksajdlkasjddddddddddddddddddddddddddd";
 
     if ( ! dataWriter->canWrite(d->filename) || ! dataWriter->write(d->filename)) {
+        qDebug() << "lksajdlkasjddddddddddddddddddddddddddd";
 
         emit showError(QString(tr("Writing to file \"%1\" with exporter \"%2\" failed.")).arg(d->filename).arg(dataWriter->description()), 3000);
         emit failure(this);
